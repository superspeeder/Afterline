// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: afterline/asset.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_afterline_2fasset_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_afterline_2fasset_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_afterline_2fasset_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_afterline_2fasset_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[8]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_afterline_2fasset_2eproto;
namespace afterline {
class AdminAssetStatusOverrideRequest;
struct AdminAssetStatusOverrideRequestDefaultTypeInternal;
extern AdminAssetStatusOverrideRequestDefaultTypeInternal _AdminAssetStatusOverrideRequest_default_instance_;
class AdminAssetStatusOverrideResponse;
struct AdminAssetStatusOverrideResponseDefaultTypeInternal;
extern AdminAssetStatusOverrideResponseDefaultTypeInternal _AdminAssetStatusOverrideResponse_default_instance_;
class AssetStatusRequest;
struct AssetStatusRequestDefaultTypeInternal;
extern AssetStatusRequestDefaultTypeInternal _AssetStatusRequest_default_instance_;
class AssetStatusResponse;
struct AssetStatusResponseDefaultTypeInternal;
extern AssetStatusResponseDefaultTypeInternal _AssetStatusResponse_default_instance_;
class GameAssetStatusRequest;
struct GameAssetStatusRequestDefaultTypeInternal;
extern GameAssetStatusRequestDefaultTypeInternal _GameAssetStatusRequest_default_instance_;
class GameAssetStatusResponse;
struct GameAssetStatusResponseDefaultTypeInternal;
extern GameAssetStatusResponseDefaultTypeInternal _GameAssetStatusResponse_default_instance_;
class IconSetInfo;
struct IconSetInfoDefaultTypeInternal;
extern IconSetInfoDefaultTypeInternal _IconSetInfo_default_instance_;
class IconSetInfo_IconInfo;
struct IconSetInfo_IconInfoDefaultTypeInternal;
extern IconSetInfo_IconInfoDefaultTypeInternal _IconSetInfo_IconInfo_default_instance_;
}  // namespace afterline
PROTOBUF_NAMESPACE_OPEN
template<> ::afterline::AdminAssetStatusOverrideRequest* Arena::CreateMaybeMessage<::afterline::AdminAssetStatusOverrideRequest>(Arena*);
template<> ::afterline::AdminAssetStatusOverrideResponse* Arena::CreateMaybeMessage<::afterline::AdminAssetStatusOverrideResponse>(Arena*);
template<> ::afterline::AssetStatusRequest* Arena::CreateMaybeMessage<::afterline::AssetStatusRequest>(Arena*);
template<> ::afterline::AssetStatusResponse* Arena::CreateMaybeMessage<::afterline::AssetStatusResponse>(Arena*);
template<> ::afterline::GameAssetStatusRequest* Arena::CreateMaybeMessage<::afterline::GameAssetStatusRequest>(Arena*);
template<> ::afterline::GameAssetStatusResponse* Arena::CreateMaybeMessage<::afterline::GameAssetStatusResponse>(Arena*);
template<> ::afterline::IconSetInfo* Arena::CreateMaybeMessage<::afterline::IconSetInfo>(Arena*);
template<> ::afterline::IconSetInfo_IconInfo* Arena::CreateMaybeMessage<::afterline::IconSetInfo_IconInfo>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace afterline {

// ===================================================================

class IconSetInfo_IconInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:afterline.IconSetInfo.IconInfo) */ {
 public:
  inline IconSetInfo_IconInfo() : IconSetInfo_IconInfo(nullptr) {}
  ~IconSetInfo_IconInfo() override;
  explicit constexpr IconSetInfo_IconInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IconSetInfo_IconInfo(const IconSetInfo_IconInfo& from);
  IconSetInfo_IconInfo(IconSetInfo_IconInfo&& from) noexcept
    : IconSetInfo_IconInfo() {
    *this = ::std::move(from);
  }

  inline IconSetInfo_IconInfo& operator=(const IconSetInfo_IconInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline IconSetInfo_IconInfo& operator=(IconSetInfo_IconInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IconSetInfo_IconInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const IconSetInfo_IconInfo* internal_default_instance() {
    return reinterpret_cast<const IconSetInfo_IconInfo*>(
               &_IconSetInfo_IconInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(IconSetInfo_IconInfo& a, IconSetInfo_IconInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(IconSetInfo_IconInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IconSetInfo_IconInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IconSetInfo_IconInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IconSetInfo_IconInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IconSetInfo_IconInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const IconSetInfo_IconInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IconSetInfo_IconInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "afterline.IconSetInfo.IconInfo";
  }
  protected:
  explicit IconSetInfo_IconInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kImageUrlFieldNumber = 1,
    kWidthFieldNumber = 2,
    kHeightFieldNumber = 3,
  };
  // string image_url = 1;
  void clear_image_url();
  const std::string& image_url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_image_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_image_url();
  PROTOBUF_NODISCARD std::string* release_image_url();
  void set_allocated_image_url(std::string* image_url);
  private:
  const std::string& _internal_image_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_image_url(const std::string& value);
  std::string* _internal_mutable_image_url();
  public:

  // uint32 width = 2;
  void clear_width();
  uint32_t width() const;
  void set_width(uint32_t value);
  private:
  uint32_t _internal_width() const;
  void _internal_set_width(uint32_t value);
  public:

  // uint32 height = 3;
  void clear_height();
  uint32_t height() const;
  void set_height(uint32_t value);
  private:
  uint32_t _internal_height() const;
  void _internal_set_height(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:afterline.IconSetInfo.IconInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr image_url_;
  uint32_t width_;
  uint32_t height_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_afterline_2fasset_2eproto;
};
// -------------------------------------------------------------------

class IconSetInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:afterline.IconSetInfo) */ {
 public:
  inline IconSetInfo() : IconSetInfo(nullptr) {}
  ~IconSetInfo() override;
  explicit constexpr IconSetInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IconSetInfo(const IconSetInfo& from);
  IconSetInfo(IconSetInfo&& from) noexcept
    : IconSetInfo() {
    *this = ::std::move(from);
  }

  inline IconSetInfo& operator=(const IconSetInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline IconSetInfo& operator=(IconSetInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IconSetInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const IconSetInfo* internal_default_instance() {
    return reinterpret_cast<const IconSetInfo*>(
               &_IconSetInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(IconSetInfo& a, IconSetInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(IconSetInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IconSetInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IconSetInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IconSetInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IconSetInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const IconSetInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IconSetInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "afterline.IconSetInfo";
  }
  protected:
  explicit IconSetInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef IconSetInfo_IconInfo IconInfo;

  // accessors -------------------------------------------------------

  enum : int {
    kIconsFieldNumber = 1,
  };
  // repeated .afterline.IconSetInfo.IconInfo icons = 1;
  int icons_size() const;
  private:
  int _internal_icons_size() const;
  public:
  void clear_icons();
  ::afterline::IconSetInfo_IconInfo* mutable_icons(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::afterline::IconSetInfo_IconInfo >*
      mutable_icons();
  private:
  const ::afterline::IconSetInfo_IconInfo& _internal_icons(int index) const;
  ::afterline::IconSetInfo_IconInfo* _internal_add_icons();
  public:
  const ::afterline::IconSetInfo_IconInfo& icons(int index) const;
  ::afterline::IconSetInfo_IconInfo* add_icons();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::afterline::IconSetInfo_IconInfo >&
      icons() const;

  // @@protoc_insertion_point(class_scope:afterline.IconSetInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::afterline::IconSetInfo_IconInfo > icons_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_afterline_2fasset_2eproto;
};
// -------------------------------------------------------------------

class AssetStatusRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:afterline.AssetStatusRequest) */ {
 public:
  inline AssetStatusRequest() : AssetStatusRequest(nullptr) {}
  ~AssetStatusRequest() override;
  explicit constexpr AssetStatusRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AssetStatusRequest(const AssetStatusRequest& from);
  AssetStatusRequest(AssetStatusRequest&& from) noexcept
    : AssetStatusRequest() {
    *this = ::std::move(from);
  }

  inline AssetStatusRequest& operator=(const AssetStatusRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline AssetStatusRequest& operator=(AssetStatusRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AssetStatusRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const AssetStatusRequest* internal_default_instance() {
    return reinterpret_cast<const AssetStatusRequest*>(
               &_AssetStatusRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(AssetStatusRequest& a, AssetStatusRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(AssetStatusRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AssetStatusRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AssetStatusRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AssetStatusRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AssetStatusRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AssetStatusRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AssetStatusRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "afterline.AssetStatusRequest";
  }
  protected:
  explicit AssetStatusRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSessionIdFieldNumber = 1,
    kResourceIdFieldNumber = 2,
  };
  // fixed64 session_id = 1;
  void clear_session_id();
  uint64_t session_id() const;
  void set_session_id(uint64_t value);
  private:
  uint64_t _internal_session_id() const;
  void _internal_set_session_id(uint64_t value);
  public:

  // fixed64 resource_id = 2;
  void clear_resource_id();
  uint64_t resource_id() const;
  void set_resource_id(uint64_t value);
  private:
  uint64_t _internal_resource_id() const;
  void _internal_set_resource_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:afterline.AssetStatusRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint64_t session_id_;
  uint64_t resource_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_afterline_2fasset_2eproto;
};
// -------------------------------------------------------------------

class GameAssetStatusRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:afterline.GameAssetStatusRequest) */ {
 public:
  inline GameAssetStatusRequest() : GameAssetStatusRequest(nullptr) {}
  ~GameAssetStatusRequest() override;
  explicit constexpr GameAssetStatusRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GameAssetStatusRequest(const GameAssetStatusRequest& from);
  GameAssetStatusRequest(GameAssetStatusRequest&& from) noexcept
    : GameAssetStatusRequest() {
    *this = ::std::move(from);
  }

  inline GameAssetStatusRequest& operator=(const GameAssetStatusRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GameAssetStatusRequest& operator=(GameAssetStatusRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GameAssetStatusRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GameAssetStatusRequest* internal_default_instance() {
    return reinterpret_cast<const GameAssetStatusRequest*>(
               &_GameAssetStatusRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(GameAssetStatusRequest& a, GameAssetStatusRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GameAssetStatusRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GameAssetStatusRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GameAssetStatusRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GameAssetStatusRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GameAssetStatusRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GameAssetStatusRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GameAssetStatusRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "afterline.GameAssetStatusRequest";
  }
  protected:
  explicit GameAssetStatusRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSessionIdFieldNumber = 1,
    kGameIdFieldNumber = 2,
    kResourceIdFieldNumber = 3,
  };
  // fixed64 session_id = 1;
  void clear_session_id();
  uint64_t session_id() const;
  void set_session_id(uint64_t value);
  private:
  uint64_t _internal_session_id() const;
  void _internal_set_session_id(uint64_t value);
  public:

  // fixed64 game_id = 2;
  void clear_game_id();
  uint64_t game_id() const;
  void set_game_id(uint64_t value);
  private:
  uint64_t _internal_game_id() const;
  void _internal_set_game_id(uint64_t value);
  public:

  // fixed64 resource_id = 3;
  void clear_resource_id();
  uint64_t resource_id() const;
  void set_resource_id(uint64_t value);
  private:
  uint64_t _internal_resource_id() const;
  void _internal_set_resource_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:afterline.GameAssetStatusRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint64_t session_id_;
  uint64_t game_id_;
  uint64_t resource_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_afterline_2fasset_2eproto;
};
// -------------------------------------------------------------------

class AssetStatusResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:afterline.AssetStatusResponse) */ {
 public:
  inline AssetStatusResponse() : AssetStatusResponse(nullptr) {}
  ~AssetStatusResponse() override;
  explicit constexpr AssetStatusResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AssetStatusResponse(const AssetStatusResponse& from);
  AssetStatusResponse(AssetStatusResponse&& from) noexcept
    : AssetStatusResponse() {
    *this = ::std::move(from);
  }

  inline AssetStatusResponse& operator=(const AssetStatusResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline AssetStatusResponse& operator=(AssetStatusResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AssetStatusResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const AssetStatusResponse* internal_default_instance() {
    return reinterpret_cast<const AssetStatusResponse*>(
               &_AssetStatusResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(AssetStatusResponse& a, AssetStatusResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(AssetStatusResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AssetStatusResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AssetStatusResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AssetStatusResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AssetStatusResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AssetStatusResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AssetStatusResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "afterline.AssetStatusResponse";
  }
  protected:
  explicit AssetStatusResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResourceIdFieldNumber = 1,
    kAvailableFieldNumber = 2,
  };
  // fixed64 resource_id = 1;
  void clear_resource_id();
  uint64_t resource_id() const;
  void set_resource_id(uint64_t value);
  private:
  uint64_t _internal_resource_id() const;
  void _internal_set_resource_id(uint64_t value);
  public:

  // bool available = 2;
  void clear_available();
  bool available() const;
  void set_available(bool value);
  private:
  bool _internal_available() const;
  void _internal_set_available(bool value);
  public:

  // @@protoc_insertion_point(class_scope:afterline.AssetStatusResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint64_t resource_id_;
  bool available_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_afterline_2fasset_2eproto;
};
// -------------------------------------------------------------------

class GameAssetStatusResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:afterline.GameAssetStatusResponse) */ {
 public:
  inline GameAssetStatusResponse() : GameAssetStatusResponse(nullptr) {}
  ~GameAssetStatusResponse() override;
  explicit constexpr GameAssetStatusResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GameAssetStatusResponse(const GameAssetStatusResponse& from);
  GameAssetStatusResponse(GameAssetStatusResponse&& from) noexcept
    : GameAssetStatusResponse() {
    *this = ::std::move(from);
  }

  inline GameAssetStatusResponse& operator=(const GameAssetStatusResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GameAssetStatusResponse& operator=(GameAssetStatusResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GameAssetStatusResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GameAssetStatusResponse* internal_default_instance() {
    return reinterpret_cast<const GameAssetStatusResponse*>(
               &_GameAssetStatusResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(GameAssetStatusResponse& a, GameAssetStatusResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GameAssetStatusResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GameAssetStatusResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GameAssetStatusResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GameAssetStatusResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GameAssetStatusResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GameAssetStatusResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GameAssetStatusResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "afterline.GameAssetStatusResponse";
  }
  protected:
  explicit GameAssetStatusResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGameIdFieldNumber = 1,
    kResourceIdFieldNumber = 2,
    kAvailableFieldNumber = 3,
  };
  // fixed64 game_id = 1;
  void clear_game_id();
  uint64_t game_id() const;
  void set_game_id(uint64_t value);
  private:
  uint64_t _internal_game_id() const;
  void _internal_set_game_id(uint64_t value);
  public:

  // fixed64 resource_id = 2;
  void clear_resource_id();
  uint64_t resource_id() const;
  void set_resource_id(uint64_t value);
  private:
  uint64_t _internal_resource_id() const;
  void _internal_set_resource_id(uint64_t value);
  public:

  // bool available = 3;
  void clear_available();
  bool available() const;
  void set_available(bool value);
  private:
  bool _internal_available() const;
  void _internal_set_available(bool value);
  public:

  // @@protoc_insertion_point(class_scope:afterline.GameAssetStatusResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint64_t game_id_;
  uint64_t resource_id_;
  bool available_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_afterline_2fasset_2eproto;
};
// -------------------------------------------------------------------

class AdminAssetStatusOverrideRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:afterline.AdminAssetStatusOverrideRequest) */ {
 public:
  inline AdminAssetStatusOverrideRequest() : AdminAssetStatusOverrideRequest(nullptr) {}
  ~AdminAssetStatusOverrideRequest() override;
  explicit constexpr AdminAssetStatusOverrideRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AdminAssetStatusOverrideRequest(const AdminAssetStatusOverrideRequest& from);
  AdminAssetStatusOverrideRequest(AdminAssetStatusOverrideRequest&& from) noexcept
    : AdminAssetStatusOverrideRequest() {
    *this = ::std::move(from);
  }

  inline AdminAssetStatusOverrideRequest& operator=(const AdminAssetStatusOverrideRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline AdminAssetStatusOverrideRequest& operator=(AdminAssetStatusOverrideRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AdminAssetStatusOverrideRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const AdminAssetStatusOverrideRequest* internal_default_instance() {
    return reinterpret_cast<const AdminAssetStatusOverrideRequest*>(
               &_AdminAssetStatusOverrideRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(AdminAssetStatusOverrideRequest& a, AdminAssetStatusOverrideRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(AdminAssetStatusOverrideRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AdminAssetStatusOverrideRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AdminAssetStatusOverrideRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AdminAssetStatusOverrideRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AdminAssetStatusOverrideRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AdminAssetStatusOverrideRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AdminAssetStatusOverrideRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "afterline.AdminAssetStatusOverrideRequest";
  }
  protected:
  explicit AdminAssetStatusOverrideRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSessionIdFieldNumber = 1,
    kOverrideFieldNumber = 2,
  };
  // fixed64 session_id = 1;
  void clear_session_id();
  uint64_t session_id() const;
  void set_session_id(uint64_t value);
  private:
  uint64_t _internal_session_id() const;
  void _internal_set_session_id(uint64_t value);
  public:

  // bool override = 2;
  void clear_override();
  bool override() const;
  void set_override(bool value);
  private:
  bool _internal_override() const;
  void _internal_set_override(bool value);
  public:

  // @@protoc_insertion_point(class_scope:afterline.AdminAssetStatusOverrideRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint64_t session_id_;
  bool override_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_afterline_2fasset_2eproto;
};
// -------------------------------------------------------------------

class AdminAssetStatusOverrideResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:afterline.AdminAssetStatusOverrideResponse) */ {
 public:
  inline AdminAssetStatusOverrideResponse() : AdminAssetStatusOverrideResponse(nullptr) {}
  ~AdminAssetStatusOverrideResponse() override;
  explicit constexpr AdminAssetStatusOverrideResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AdminAssetStatusOverrideResponse(const AdminAssetStatusOverrideResponse& from);
  AdminAssetStatusOverrideResponse(AdminAssetStatusOverrideResponse&& from) noexcept
    : AdminAssetStatusOverrideResponse() {
    *this = ::std::move(from);
  }

  inline AdminAssetStatusOverrideResponse& operator=(const AdminAssetStatusOverrideResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline AdminAssetStatusOverrideResponse& operator=(AdminAssetStatusOverrideResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AdminAssetStatusOverrideResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const AdminAssetStatusOverrideResponse* internal_default_instance() {
    return reinterpret_cast<const AdminAssetStatusOverrideResponse*>(
               &_AdminAssetStatusOverrideResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(AdminAssetStatusOverrideResponse& a, AdminAssetStatusOverrideResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(AdminAssetStatusOverrideResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AdminAssetStatusOverrideResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AdminAssetStatusOverrideResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AdminAssetStatusOverrideResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AdminAssetStatusOverrideResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AdminAssetStatusOverrideResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AdminAssetStatusOverrideResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "afterline.AdminAssetStatusOverrideResponse";
  }
  protected:
  explicit AdminAssetStatusOverrideResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSucceededFieldNumber = 1,
  };
  // bool succeeded = 1;
  void clear_succeeded();
  bool succeeded() const;
  void set_succeeded(bool value);
  private:
  bool _internal_succeeded() const;
  void _internal_set_succeeded(bool value);
  public:

  // @@protoc_insertion_point(class_scope:afterline.AdminAssetStatusOverrideResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  bool succeeded_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_afterline_2fasset_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// IconSetInfo_IconInfo

// string image_url = 1;
inline void IconSetInfo_IconInfo::clear_image_url() {
  image_url_.ClearToEmpty();
}
inline const std::string& IconSetInfo_IconInfo::image_url() const {
  // @@protoc_insertion_point(field_get:afterline.IconSetInfo.IconInfo.image_url)
  return _internal_image_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void IconSetInfo_IconInfo::set_image_url(ArgT0&& arg0, ArgT... args) {
 
 image_url_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:afterline.IconSetInfo.IconInfo.image_url)
}
inline std::string* IconSetInfo_IconInfo::mutable_image_url() {
  std::string* _s = _internal_mutable_image_url();
  // @@protoc_insertion_point(field_mutable:afterline.IconSetInfo.IconInfo.image_url)
  return _s;
}
inline const std::string& IconSetInfo_IconInfo::_internal_image_url() const {
  return image_url_.Get();
}
inline void IconSetInfo_IconInfo::_internal_set_image_url(const std::string& value) {
  
  image_url_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* IconSetInfo_IconInfo::_internal_mutable_image_url() {
  
  return image_url_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* IconSetInfo_IconInfo::release_image_url() {
  // @@protoc_insertion_point(field_release:afterline.IconSetInfo.IconInfo.image_url)
  return image_url_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void IconSetInfo_IconInfo::set_allocated_image_url(std::string* image_url) {
  if (image_url != nullptr) {
    
  } else {
    
  }
  image_url_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), image_url,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (image_url_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    image_url_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:afterline.IconSetInfo.IconInfo.image_url)
}

// uint32 width = 2;
inline void IconSetInfo_IconInfo::clear_width() {
  width_ = 0u;
}
inline uint32_t IconSetInfo_IconInfo::_internal_width() const {
  return width_;
}
inline uint32_t IconSetInfo_IconInfo::width() const {
  // @@protoc_insertion_point(field_get:afterline.IconSetInfo.IconInfo.width)
  return _internal_width();
}
inline void IconSetInfo_IconInfo::_internal_set_width(uint32_t value) {
  
  width_ = value;
}
inline void IconSetInfo_IconInfo::set_width(uint32_t value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:afterline.IconSetInfo.IconInfo.width)
}

// uint32 height = 3;
inline void IconSetInfo_IconInfo::clear_height() {
  height_ = 0u;
}
inline uint32_t IconSetInfo_IconInfo::_internal_height() const {
  return height_;
}
inline uint32_t IconSetInfo_IconInfo::height() const {
  // @@protoc_insertion_point(field_get:afterline.IconSetInfo.IconInfo.height)
  return _internal_height();
}
inline void IconSetInfo_IconInfo::_internal_set_height(uint32_t value) {
  
  height_ = value;
}
inline void IconSetInfo_IconInfo::set_height(uint32_t value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:afterline.IconSetInfo.IconInfo.height)
}

// -------------------------------------------------------------------

// IconSetInfo

// repeated .afterline.IconSetInfo.IconInfo icons = 1;
inline int IconSetInfo::_internal_icons_size() const {
  return icons_.size();
}
inline int IconSetInfo::icons_size() const {
  return _internal_icons_size();
}
inline void IconSetInfo::clear_icons() {
  icons_.Clear();
}
inline ::afterline::IconSetInfo_IconInfo* IconSetInfo::mutable_icons(int index) {
  // @@protoc_insertion_point(field_mutable:afterline.IconSetInfo.icons)
  return icons_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::afterline::IconSetInfo_IconInfo >*
IconSetInfo::mutable_icons() {
  // @@protoc_insertion_point(field_mutable_list:afterline.IconSetInfo.icons)
  return &icons_;
}
inline const ::afterline::IconSetInfo_IconInfo& IconSetInfo::_internal_icons(int index) const {
  return icons_.Get(index);
}
inline const ::afterline::IconSetInfo_IconInfo& IconSetInfo::icons(int index) const {
  // @@protoc_insertion_point(field_get:afterline.IconSetInfo.icons)
  return _internal_icons(index);
}
inline ::afterline::IconSetInfo_IconInfo* IconSetInfo::_internal_add_icons() {
  return icons_.Add();
}
inline ::afterline::IconSetInfo_IconInfo* IconSetInfo::add_icons() {
  ::afterline::IconSetInfo_IconInfo* _add = _internal_add_icons();
  // @@protoc_insertion_point(field_add:afterline.IconSetInfo.icons)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::afterline::IconSetInfo_IconInfo >&
IconSetInfo::icons() const {
  // @@protoc_insertion_point(field_list:afterline.IconSetInfo.icons)
  return icons_;
}

// -------------------------------------------------------------------

// AssetStatusRequest

// fixed64 session_id = 1;
inline void AssetStatusRequest::clear_session_id() {
  session_id_ = uint64_t{0u};
}
inline uint64_t AssetStatusRequest::_internal_session_id() const {
  return session_id_;
}
inline uint64_t AssetStatusRequest::session_id() const {
  // @@protoc_insertion_point(field_get:afterline.AssetStatusRequest.session_id)
  return _internal_session_id();
}
inline void AssetStatusRequest::_internal_set_session_id(uint64_t value) {
  
  session_id_ = value;
}
inline void AssetStatusRequest::set_session_id(uint64_t value) {
  _internal_set_session_id(value);
  // @@protoc_insertion_point(field_set:afterline.AssetStatusRequest.session_id)
}

// fixed64 resource_id = 2;
inline void AssetStatusRequest::clear_resource_id() {
  resource_id_ = uint64_t{0u};
}
inline uint64_t AssetStatusRequest::_internal_resource_id() const {
  return resource_id_;
}
inline uint64_t AssetStatusRequest::resource_id() const {
  // @@protoc_insertion_point(field_get:afterline.AssetStatusRequest.resource_id)
  return _internal_resource_id();
}
inline void AssetStatusRequest::_internal_set_resource_id(uint64_t value) {
  
  resource_id_ = value;
}
inline void AssetStatusRequest::set_resource_id(uint64_t value) {
  _internal_set_resource_id(value);
  // @@protoc_insertion_point(field_set:afterline.AssetStatusRequest.resource_id)
}

// -------------------------------------------------------------------

// GameAssetStatusRequest

// fixed64 session_id = 1;
inline void GameAssetStatusRequest::clear_session_id() {
  session_id_ = uint64_t{0u};
}
inline uint64_t GameAssetStatusRequest::_internal_session_id() const {
  return session_id_;
}
inline uint64_t GameAssetStatusRequest::session_id() const {
  // @@protoc_insertion_point(field_get:afterline.GameAssetStatusRequest.session_id)
  return _internal_session_id();
}
inline void GameAssetStatusRequest::_internal_set_session_id(uint64_t value) {
  
  session_id_ = value;
}
inline void GameAssetStatusRequest::set_session_id(uint64_t value) {
  _internal_set_session_id(value);
  // @@protoc_insertion_point(field_set:afterline.GameAssetStatusRequest.session_id)
}

// fixed64 game_id = 2;
inline void GameAssetStatusRequest::clear_game_id() {
  game_id_ = uint64_t{0u};
}
inline uint64_t GameAssetStatusRequest::_internal_game_id() const {
  return game_id_;
}
inline uint64_t GameAssetStatusRequest::game_id() const {
  // @@protoc_insertion_point(field_get:afterline.GameAssetStatusRequest.game_id)
  return _internal_game_id();
}
inline void GameAssetStatusRequest::_internal_set_game_id(uint64_t value) {
  
  game_id_ = value;
}
inline void GameAssetStatusRequest::set_game_id(uint64_t value) {
  _internal_set_game_id(value);
  // @@protoc_insertion_point(field_set:afterline.GameAssetStatusRequest.game_id)
}

// fixed64 resource_id = 3;
inline void GameAssetStatusRequest::clear_resource_id() {
  resource_id_ = uint64_t{0u};
}
inline uint64_t GameAssetStatusRequest::_internal_resource_id() const {
  return resource_id_;
}
inline uint64_t GameAssetStatusRequest::resource_id() const {
  // @@protoc_insertion_point(field_get:afterline.GameAssetStatusRequest.resource_id)
  return _internal_resource_id();
}
inline void GameAssetStatusRequest::_internal_set_resource_id(uint64_t value) {
  
  resource_id_ = value;
}
inline void GameAssetStatusRequest::set_resource_id(uint64_t value) {
  _internal_set_resource_id(value);
  // @@protoc_insertion_point(field_set:afterline.GameAssetStatusRequest.resource_id)
}

// -------------------------------------------------------------------

// AssetStatusResponse

// fixed64 resource_id = 1;
inline void AssetStatusResponse::clear_resource_id() {
  resource_id_ = uint64_t{0u};
}
inline uint64_t AssetStatusResponse::_internal_resource_id() const {
  return resource_id_;
}
inline uint64_t AssetStatusResponse::resource_id() const {
  // @@protoc_insertion_point(field_get:afterline.AssetStatusResponse.resource_id)
  return _internal_resource_id();
}
inline void AssetStatusResponse::_internal_set_resource_id(uint64_t value) {
  
  resource_id_ = value;
}
inline void AssetStatusResponse::set_resource_id(uint64_t value) {
  _internal_set_resource_id(value);
  // @@protoc_insertion_point(field_set:afterline.AssetStatusResponse.resource_id)
}

// bool available = 2;
inline void AssetStatusResponse::clear_available() {
  available_ = false;
}
inline bool AssetStatusResponse::_internal_available() const {
  return available_;
}
inline bool AssetStatusResponse::available() const {
  // @@protoc_insertion_point(field_get:afterline.AssetStatusResponse.available)
  return _internal_available();
}
inline void AssetStatusResponse::_internal_set_available(bool value) {
  
  available_ = value;
}
inline void AssetStatusResponse::set_available(bool value) {
  _internal_set_available(value);
  // @@protoc_insertion_point(field_set:afterline.AssetStatusResponse.available)
}

// -------------------------------------------------------------------

// GameAssetStatusResponse

// fixed64 game_id = 1;
inline void GameAssetStatusResponse::clear_game_id() {
  game_id_ = uint64_t{0u};
}
inline uint64_t GameAssetStatusResponse::_internal_game_id() const {
  return game_id_;
}
inline uint64_t GameAssetStatusResponse::game_id() const {
  // @@protoc_insertion_point(field_get:afterline.GameAssetStatusResponse.game_id)
  return _internal_game_id();
}
inline void GameAssetStatusResponse::_internal_set_game_id(uint64_t value) {
  
  game_id_ = value;
}
inline void GameAssetStatusResponse::set_game_id(uint64_t value) {
  _internal_set_game_id(value);
  // @@protoc_insertion_point(field_set:afterline.GameAssetStatusResponse.game_id)
}

// fixed64 resource_id = 2;
inline void GameAssetStatusResponse::clear_resource_id() {
  resource_id_ = uint64_t{0u};
}
inline uint64_t GameAssetStatusResponse::_internal_resource_id() const {
  return resource_id_;
}
inline uint64_t GameAssetStatusResponse::resource_id() const {
  // @@protoc_insertion_point(field_get:afterline.GameAssetStatusResponse.resource_id)
  return _internal_resource_id();
}
inline void GameAssetStatusResponse::_internal_set_resource_id(uint64_t value) {
  
  resource_id_ = value;
}
inline void GameAssetStatusResponse::set_resource_id(uint64_t value) {
  _internal_set_resource_id(value);
  // @@protoc_insertion_point(field_set:afterline.GameAssetStatusResponse.resource_id)
}

// bool available = 3;
inline void GameAssetStatusResponse::clear_available() {
  available_ = false;
}
inline bool GameAssetStatusResponse::_internal_available() const {
  return available_;
}
inline bool GameAssetStatusResponse::available() const {
  // @@protoc_insertion_point(field_get:afterline.GameAssetStatusResponse.available)
  return _internal_available();
}
inline void GameAssetStatusResponse::_internal_set_available(bool value) {
  
  available_ = value;
}
inline void GameAssetStatusResponse::set_available(bool value) {
  _internal_set_available(value);
  // @@protoc_insertion_point(field_set:afterline.GameAssetStatusResponse.available)
}

// -------------------------------------------------------------------

// AdminAssetStatusOverrideRequest

// fixed64 session_id = 1;
inline void AdminAssetStatusOverrideRequest::clear_session_id() {
  session_id_ = uint64_t{0u};
}
inline uint64_t AdminAssetStatusOverrideRequest::_internal_session_id() const {
  return session_id_;
}
inline uint64_t AdminAssetStatusOverrideRequest::session_id() const {
  // @@protoc_insertion_point(field_get:afterline.AdminAssetStatusOverrideRequest.session_id)
  return _internal_session_id();
}
inline void AdminAssetStatusOverrideRequest::_internal_set_session_id(uint64_t value) {
  
  session_id_ = value;
}
inline void AdminAssetStatusOverrideRequest::set_session_id(uint64_t value) {
  _internal_set_session_id(value);
  // @@protoc_insertion_point(field_set:afterline.AdminAssetStatusOverrideRequest.session_id)
}

// bool override = 2;
inline void AdminAssetStatusOverrideRequest::clear_override() {
  override_ = false;
}
inline bool AdminAssetStatusOverrideRequest::_internal_override() const {
  return override_;
}
inline bool AdminAssetStatusOverrideRequest::override() const {
  // @@protoc_insertion_point(field_get:afterline.AdminAssetStatusOverrideRequest.override)
  return _internal_override();
}
inline void AdminAssetStatusOverrideRequest::_internal_set_override(bool value) {
  
  override_ = value;
}
inline void AdminAssetStatusOverrideRequest::set_override(bool value) {
  _internal_set_override(value);
  // @@protoc_insertion_point(field_set:afterline.AdminAssetStatusOverrideRequest.override)
}

// -------------------------------------------------------------------

// AdminAssetStatusOverrideResponse

// bool succeeded = 1;
inline void AdminAssetStatusOverrideResponse::clear_succeeded() {
  succeeded_ = false;
}
inline bool AdminAssetStatusOverrideResponse::_internal_succeeded() const {
  return succeeded_;
}
inline bool AdminAssetStatusOverrideResponse::succeeded() const {
  // @@protoc_insertion_point(field_get:afterline.AdminAssetStatusOverrideResponse.succeeded)
  return _internal_succeeded();
}
inline void AdminAssetStatusOverrideResponse::_internal_set_succeeded(bool value) {
  
  succeeded_ = value;
}
inline void AdminAssetStatusOverrideResponse::set_succeeded(bool value) {
  _internal_set_succeeded(value);
  // @@protoc_insertion_point(field_set:afterline.AdminAssetStatusOverrideResponse.succeeded)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace afterline

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_afterline_2fasset_2eproto
