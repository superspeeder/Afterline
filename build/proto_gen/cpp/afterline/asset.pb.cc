// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: afterline/asset.proto

#include "afterline/asset.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG
namespace afterline {
constexpr IconSetInfo_IconInfo::IconSetInfo_IconInfo(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : image_url_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , width_(0u)
  , height_(0u){}
struct IconSetInfo_IconInfoDefaultTypeInternal {
  constexpr IconSetInfo_IconInfoDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~IconSetInfo_IconInfoDefaultTypeInternal() {}
  union {
    IconSetInfo_IconInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT IconSetInfo_IconInfoDefaultTypeInternal _IconSetInfo_IconInfo_default_instance_;
constexpr IconSetInfo::IconSetInfo(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : icons_(){}
struct IconSetInfoDefaultTypeInternal {
  constexpr IconSetInfoDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~IconSetInfoDefaultTypeInternal() {}
  union {
    IconSetInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT IconSetInfoDefaultTypeInternal _IconSetInfo_default_instance_;
constexpr AssetStatusRequest::AssetStatusRequest(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : session_id_(uint64_t{0u})
  , resource_id_(uint64_t{0u}){}
struct AssetStatusRequestDefaultTypeInternal {
  constexpr AssetStatusRequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~AssetStatusRequestDefaultTypeInternal() {}
  union {
    AssetStatusRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT AssetStatusRequestDefaultTypeInternal _AssetStatusRequest_default_instance_;
constexpr GameAssetStatusRequest::GameAssetStatusRequest(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : session_id_(uint64_t{0u})
  , game_id_(uint64_t{0u})
  , resource_id_(uint64_t{0u}){}
struct GameAssetStatusRequestDefaultTypeInternal {
  constexpr GameAssetStatusRequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~GameAssetStatusRequestDefaultTypeInternal() {}
  union {
    GameAssetStatusRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT GameAssetStatusRequestDefaultTypeInternal _GameAssetStatusRequest_default_instance_;
constexpr AssetStatusResponse::AssetStatusResponse(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : resource_id_(uint64_t{0u})
  , available_(false){}
struct AssetStatusResponseDefaultTypeInternal {
  constexpr AssetStatusResponseDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~AssetStatusResponseDefaultTypeInternal() {}
  union {
    AssetStatusResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT AssetStatusResponseDefaultTypeInternal _AssetStatusResponse_default_instance_;
constexpr GameAssetStatusResponse::GameAssetStatusResponse(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : game_id_(uint64_t{0u})
  , resource_id_(uint64_t{0u})
  , available_(false){}
struct GameAssetStatusResponseDefaultTypeInternal {
  constexpr GameAssetStatusResponseDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~GameAssetStatusResponseDefaultTypeInternal() {}
  union {
    GameAssetStatusResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT GameAssetStatusResponseDefaultTypeInternal _GameAssetStatusResponse_default_instance_;
constexpr AdminAssetStatusOverrideRequest::AdminAssetStatusOverrideRequest(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : session_id_(uint64_t{0u})
  , override_(false){}
struct AdminAssetStatusOverrideRequestDefaultTypeInternal {
  constexpr AdminAssetStatusOverrideRequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~AdminAssetStatusOverrideRequestDefaultTypeInternal() {}
  union {
    AdminAssetStatusOverrideRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT AdminAssetStatusOverrideRequestDefaultTypeInternal _AdminAssetStatusOverrideRequest_default_instance_;
constexpr AdminAssetStatusOverrideResponse::AdminAssetStatusOverrideResponse(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : succeeded_(false){}
struct AdminAssetStatusOverrideResponseDefaultTypeInternal {
  constexpr AdminAssetStatusOverrideResponseDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~AdminAssetStatusOverrideResponseDefaultTypeInternal() {}
  union {
    AdminAssetStatusOverrideResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT AdminAssetStatusOverrideResponseDefaultTypeInternal _AdminAssetStatusOverrideResponse_default_instance_;
}  // namespace afterline
static ::PROTOBUF_NAMESPACE_ID::Metadata file_level_metadata_afterline_2fasset_2eproto[8];
static constexpr ::PROTOBUF_NAMESPACE_ID::EnumDescriptor const** file_level_enum_descriptors_afterline_2fasset_2eproto = nullptr;
static constexpr ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor const** file_level_service_descriptors_afterline_2fasset_2eproto = nullptr;

const uint32_t TableStruct_afterline_2fasset_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::afterline::IconSetInfo_IconInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::afterline::IconSetInfo_IconInfo, image_url_),
  PROTOBUF_FIELD_OFFSET(::afterline::IconSetInfo_IconInfo, width_),
  PROTOBUF_FIELD_OFFSET(::afterline::IconSetInfo_IconInfo, height_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::afterline::IconSetInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::afterline::IconSetInfo, icons_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::afterline::AssetStatusRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::afterline::AssetStatusRequest, session_id_),
  PROTOBUF_FIELD_OFFSET(::afterline::AssetStatusRequest, resource_id_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::afterline::GameAssetStatusRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::afterline::GameAssetStatusRequest, session_id_),
  PROTOBUF_FIELD_OFFSET(::afterline::GameAssetStatusRequest, game_id_),
  PROTOBUF_FIELD_OFFSET(::afterline::GameAssetStatusRequest, resource_id_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::afterline::AssetStatusResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::afterline::AssetStatusResponse, resource_id_),
  PROTOBUF_FIELD_OFFSET(::afterline::AssetStatusResponse, available_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::afterline::GameAssetStatusResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::afterline::GameAssetStatusResponse, game_id_),
  PROTOBUF_FIELD_OFFSET(::afterline::GameAssetStatusResponse, resource_id_),
  PROTOBUF_FIELD_OFFSET(::afterline::GameAssetStatusResponse, available_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::afterline::AdminAssetStatusOverrideRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::afterline::AdminAssetStatusOverrideRequest, session_id_),
  PROTOBUF_FIELD_OFFSET(::afterline::AdminAssetStatusOverrideRequest, override_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::afterline::AdminAssetStatusOverrideResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::afterline::AdminAssetStatusOverrideResponse, succeeded_),
};
static const ::PROTOBUF_NAMESPACE_ID::internal::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, -1, -1, sizeof(::afterline::IconSetInfo_IconInfo)},
  { 9, -1, -1, sizeof(::afterline::IconSetInfo)},
  { 16, -1, -1, sizeof(::afterline::AssetStatusRequest)},
  { 24, -1, -1, sizeof(::afterline::GameAssetStatusRequest)},
  { 33, -1, -1, sizeof(::afterline::AssetStatusResponse)},
  { 41, -1, -1, sizeof(::afterline::GameAssetStatusResponse)},
  { 50, -1, -1, sizeof(::afterline::AdminAssetStatusOverrideRequest)},
  { 58, -1, -1, sizeof(::afterline::AdminAssetStatusOverrideResponse)},
};

static ::PROTOBUF_NAMESPACE_ID::Message const * const file_default_instances[] = {
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::afterline::_IconSetInfo_IconInfo_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::afterline::_IconSetInfo_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::afterline::_AssetStatusRequest_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::afterline::_GameAssetStatusRequest_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::afterline::_AssetStatusResponse_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::afterline::_GameAssetStatusResponse_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::afterline::_AdminAssetStatusOverrideRequest_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::afterline::_AdminAssetStatusOverrideResponse_default_instance_),
};

const char descriptor_table_protodef_afterline_2fasset_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\025afterline/asset.proto\022\tafterline\"{\n\013Ic"
  "onSetInfo\022.\n\005icons\030\001 \003(\0132\037.afterline.Ico"
  "nSetInfo.IconInfo\032<\n\010IconInfo\022\021\n\timage_u"
  "rl\030\001 \001(\t\022\r\n\005width\030\002 \001(\r\022\016\n\006height\030\003 \001(\r\""
  "=\n\022AssetStatusRequest\022\022\n\nsession_id\030\001 \001("
  "\006\022\023\n\013resource_id\030\002 \001(\006\"R\n\026GameAssetStatu"
  "sRequest\022\022\n\nsession_id\030\001 \001(\006\022\017\n\007game_id\030"
  "\002 \001(\006\022\023\n\013resource_id\030\003 \001(\006\"=\n\023AssetStatu"
  "sResponse\022\023\n\013resource_id\030\001 \001(\006\022\021\n\tavaila"
  "ble\030\002 \001(\010\"R\n\027GameAssetStatusResponse\022\017\n\007"
  "game_id\030\001 \001(\006\022\023\n\013resource_id\030\002 \001(\006\022\021\n\tav"
  "ailable\030\003 \001(\010\"G\n\037AdminAssetStatusOverrid"
  "eRequest\022\022\n\nsession_id\030\001 \001(\006\022\020\n\010override"
  "\030\002 \001(\010\"5\n AdminAssetStatusOverrideRespon"
  "se\022\021\n\tsucceeded\030\001 \001(\010b\006proto3"
  ;
static ::PROTOBUF_NAMESPACE_ID::internal::once_flag descriptor_table_afterline_2fasset_2eproto_once;
const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_afterline_2fasset_2eproto = {
  false, false, 589, descriptor_table_protodef_afterline_2fasset_2eproto, "afterline/asset.proto", 
  &descriptor_table_afterline_2fasset_2eproto_once, nullptr, 0, 8,
  schemas, file_default_instances, TableStruct_afterline_2fasset_2eproto::offsets,
  file_level_metadata_afterline_2fasset_2eproto, file_level_enum_descriptors_afterline_2fasset_2eproto, file_level_service_descriptors_afterline_2fasset_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable* descriptor_table_afterline_2fasset_2eproto_getter() {
  return &descriptor_table_afterline_2fasset_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY static ::PROTOBUF_NAMESPACE_ID::internal::AddDescriptorsRunner dynamic_init_dummy_afterline_2fasset_2eproto(&descriptor_table_afterline_2fasset_2eproto);
namespace afterline {

// ===================================================================

class IconSetInfo_IconInfo::_Internal {
 public:
};

IconSetInfo_IconInfo::IconSetInfo_IconInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:afterline.IconSetInfo.IconInfo)
}
IconSetInfo_IconInfo::IconSetInfo_IconInfo(const IconSetInfo_IconInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  image_url_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    image_url_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_image_url().empty()) {
    image_url_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_image_url(), 
      GetArenaForAllocation());
  }
  ::memcpy(&width_, &from.width_,
    static_cast<size_t>(reinterpret_cast<char*>(&height_) -
    reinterpret_cast<char*>(&width_)) + sizeof(height_));
  // @@protoc_insertion_point(copy_constructor:afterline.IconSetInfo.IconInfo)
}

inline void IconSetInfo_IconInfo::SharedCtor() {
image_url_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  image_url_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&width_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&height_) -
    reinterpret_cast<char*>(&width_)) + sizeof(height_));
}

IconSetInfo_IconInfo::~IconSetInfo_IconInfo() {
  // @@protoc_insertion_point(destructor:afterline.IconSetInfo.IconInfo)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void IconSetInfo_IconInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  image_url_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void IconSetInfo_IconInfo::ArenaDtor(void* object) {
  IconSetInfo_IconInfo* _this = reinterpret_cast< IconSetInfo_IconInfo* >(object);
  (void)_this;
}
void IconSetInfo_IconInfo::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void IconSetInfo_IconInfo::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void IconSetInfo_IconInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:afterline.IconSetInfo.IconInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  image_url_.ClearToEmpty();
  ::memset(&width_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&height_) -
      reinterpret_cast<char*>(&width_)) + sizeof(height_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* IconSetInfo_IconInfo::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string image_url = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_image_url();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "afterline.IconSetInfo.IconInfo.image_url"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 width = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          width_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 height = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          height_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* IconSetInfo_IconInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:afterline.IconSetInfo.IconInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string image_url = 1;
  if (!this->_internal_image_url().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_image_url().data(), static_cast<int>(this->_internal_image_url().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "afterline.IconSetInfo.IconInfo.image_url");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_image_url(), target);
  }

  // uint32 width = 2;
  if (this->_internal_width() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_width(), target);
  }

  // uint32 height = 3;
  if (this->_internal_height() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(3, this->_internal_height(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:afterline.IconSetInfo.IconInfo)
  return target;
}

size_t IconSetInfo_IconInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:afterline.IconSetInfo.IconInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string image_url = 1;
  if (!this->_internal_image_url().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_image_url());
  }

  // uint32 width = 2;
  if (this->_internal_width() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_width());
  }

  // uint32 height = 3;
  if (this->_internal_height() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_height());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData IconSetInfo_IconInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    IconSetInfo_IconInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*IconSetInfo_IconInfo::GetClassData() const { return &_class_data_; }

void IconSetInfo_IconInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<IconSetInfo_IconInfo *>(to)->MergeFrom(
      static_cast<const IconSetInfo_IconInfo &>(from));
}


void IconSetInfo_IconInfo::MergeFrom(const IconSetInfo_IconInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:afterline.IconSetInfo.IconInfo)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_image_url().empty()) {
    _internal_set_image_url(from._internal_image_url());
  }
  if (from._internal_width() != 0) {
    _internal_set_width(from._internal_width());
  }
  if (from._internal_height() != 0) {
    _internal_set_height(from._internal_height());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void IconSetInfo_IconInfo::CopyFrom(const IconSetInfo_IconInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:afterline.IconSetInfo.IconInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IconSetInfo_IconInfo::IsInitialized() const {
  return true;
}

void IconSetInfo_IconInfo::InternalSwap(IconSetInfo_IconInfo* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &image_url_, lhs_arena,
      &other->image_url_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(IconSetInfo_IconInfo, height_)
      + sizeof(IconSetInfo_IconInfo::height_)
      - PROTOBUF_FIELD_OFFSET(IconSetInfo_IconInfo, width_)>(
          reinterpret_cast<char*>(&width_),
          reinterpret_cast<char*>(&other->width_));
}

::PROTOBUF_NAMESPACE_ID::Metadata IconSetInfo_IconInfo::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_afterline_2fasset_2eproto_getter, &descriptor_table_afterline_2fasset_2eproto_once,
      file_level_metadata_afterline_2fasset_2eproto[0]);
}

// ===================================================================

class IconSetInfo::_Internal {
 public:
};

IconSetInfo::IconSetInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  icons_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:afterline.IconSetInfo)
}
IconSetInfo::IconSetInfo(const IconSetInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      icons_(from.icons_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:afterline.IconSetInfo)
}

inline void IconSetInfo::SharedCtor() {
}

IconSetInfo::~IconSetInfo() {
  // @@protoc_insertion_point(destructor:afterline.IconSetInfo)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void IconSetInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void IconSetInfo::ArenaDtor(void* object) {
  IconSetInfo* _this = reinterpret_cast< IconSetInfo* >(object);
  (void)_this;
}
void IconSetInfo::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void IconSetInfo::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void IconSetInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:afterline.IconSetInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  icons_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* IconSetInfo::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .afterline.IconSetInfo.IconInfo icons = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_icons(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* IconSetInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:afterline.IconSetInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .afterline.IconSetInfo.IconInfo icons = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_icons_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, this->_internal_icons(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:afterline.IconSetInfo)
  return target;
}

size_t IconSetInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:afterline.IconSetInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .afterline.IconSetInfo.IconInfo icons = 1;
  total_size += 1UL * this->_internal_icons_size();
  for (const auto& msg : this->icons_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData IconSetInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    IconSetInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*IconSetInfo::GetClassData() const { return &_class_data_; }

void IconSetInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<IconSetInfo *>(to)->MergeFrom(
      static_cast<const IconSetInfo &>(from));
}


void IconSetInfo::MergeFrom(const IconSetInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:afterline.IconSetInfo)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  icons_.MergeFrom(from.icons_);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void IconSetInfo::CopyFrom(const IconSetInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:afterline.IconSetInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IconSetInfo::IsInitialized() const {
  return true;
}

void IconSetInfo::InternalSwap(IconSetInfo* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  icons_.InternalSwap(&other->icons_);
}

::PROTOBUF_NAMESPACE_ID::Metadata IconSetInfo::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_afterline_2fasset_2eproto_getter, &descriptor_table_afterline_2fasset_2eproto_once,
      file_level_metadata_afterline_2fasset_2eproto[1]);
}

// ===================================================================

class AssetStatusRequest::_Internal {
 public:
};

AssetStatusRequest::AssetStatusRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:afterline.AssetStatusRequest)
}
AssetStatusRequest::AssetStatusRequest(const AssetStatusRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&session_id_, &from.session_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&resource_id_) -
    reinterpret_cast<char*>(&session_id_)) + sizeof(resource_id_));
  // @@protoc_insertion_point(copy_constructor:afterline.AssetStatusRequest)
}

inline void AssetStatusRequest::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&session_id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&resource_id_) -
    reinterpret_cast<char*>(&session_id_)) + sizeof(resource_id_));
}

AssetStatusRequest::~AssetStatusRequest() {
  // @@protoc_insertion_point(destructor:afterline.AssetStatusRequest)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void AssetStatusRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void AssetStatusRequest::ArenaDtor(void* object) {
  AssetStatusRequest* _this = reinterpret_cast< AssetStatusRequest* >(object);
  (void)_this;
}
void AssetStatusRequest::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void AssetStatusRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void AssetStatusRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:afterline.AssetStatusRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&session_id_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&resource_id_) -
      reinterpret_cast<char*>(&session_id_)) + sizeof(resource_id_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AssetStatusRequest::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // fixed64 session_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          session_id_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      // fixed64 resource_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          resource_id_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AssetStatusRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:afterline.AssetStatusRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // fixed64 session_id = 1;
  if (this->_internal_session_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFixed64ToArray(1, this->_internal_session_id(), target);
  }

  // fixed64 resource_id = 2;
  if (this->_internal_resource_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFixed64ToArray(2, this->_internal_resource_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:afterline.AssetStatusRequest)
  return target;
}

size_t AssetStatusRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:afterline.AssetStatusRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // fixed64 session_id = 1;
  if (this->_internal_session_id() != 0) {
    total_size += 1 + 8;
  }

  // fixed64 resource_id = 2;
  if (this->_internal_resource_id() != 0) {
    total_size += 1 + 8;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AssetStatusRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    AssetStatusRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AssetStatusRequest::GetClassData() const { return &_class_data_; }

void AssetStatusRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<AssetStatusRequest *>(to)->MergeFrom(
      static_cast<const AssetStatusRequest &>(from));
}


void AssetStatusRequest::MergeFrom(const AssetStatusRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:afterline.AssetStatusRequest)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_session_id() != 0) {
    _internal_set_session_id(from._internal_session_id());
  }
  if (from._internal_resource_id() != 0) {
    _internal_set_resource_id(from._internal_resource_id());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AssetStatusRequest::CopyFrom(const AssetStatusRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:afterline.AssetStatusRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AssetStatusRequest::IsInitialized() const {
  return true;
}

void AssetStatusRequest::InternalSwap(AssetStatusRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AssetStatusRequest, resource_id_)
      + sizeof(AssetStatusRequest::resource_id_)
      - PROTOBUF_FIELD_OFFSET(AssetStatusRequest, session_id_)>(
          reinterpret_cast<char*>(&session_id_),
          reinterpret_cast<char*>(&other->session_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata AssetStatusRequest::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_afterline_2fasset_2eproto_getter, &descriptor_table_afterline_2fasset_2eproto_once,
      file_level_metadata_afterline_2fasset_2eproto[2]);
}

// ===================================================================

class GameAssetStatusRequest::_Internal {
 public:
};

GameAssetStatusRequest::GameAssetStatusRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:afterline.GameAssetStatusRequest)
}
GameAssetStatusRequest::GameAssetStatusRequest(const GameAssetStatusRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&session_id_, &from.session_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&resource_id_) -
    reinterpret_cast<char*>(&session_id_)) + sizeof(resource_id_));
  // @@protoc_insertion_point(copy_constructor:afterline.GameAssetStatusRequest)
}

inline void GameAssetStatusRequest::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&session_id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&resource_id_) -
    reinterpret_cast<char*>(&session_id_)) + sizeof(resource_id_));
}

GameAssetStatusRequest::~GameAssetStatusRequest() {
  // @@protoc_insertion_point(destructor:afterline.GameAssetStatusRequest)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void GameAssetStatusRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void GameAssetStatusRequest::ArenaDtor(void* object) {
  GameAssetStatusRequest* _this = reinterpret_cast< GameAssetStatusRequest* >(object);
  (void)_this;
}
void GameAssetStatusRequest::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void GameAssetStatusRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void GameAssetStatusRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:afterline.GameAssetStatusRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&session_id_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&resource_id_) -
      reinterpret_cast<char*>(&session_id_)) + sizeof(resource_id_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GameAssetStatusRequest::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // fixed64 session_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          session_id_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      // fixed64 game_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          game_id_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      // fixed64 resource_id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          resource_id_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GameAssetStatusRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:afterline.GameAssetStatusRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // fixed64 session_id = 1;
  if (this->_internal_session_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFixed64ToArray(1, this->_internal_session_id(), target);
  }

  // fixed64 game_id = 2;
  if (this->_internal_game_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFixed64ToArray(2, this->_internal_game_id(), target);
  }

  // fixed64 resource_id = 3;
  if (this->_internal_resource_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFixed64ToArray(3, this->_internal_resource_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:afterline.GameAssetStatusRequest)
  return target;
}

size_t GameAssetStatusRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:afterline.GameAssetStatusRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // fixed64 session_id = 1;
  if (this->_internal_session_id() != 0) {
    total_size += 1 + 8;
  }

  // fixed64 game_id = 2;
  if (this->_internal_game_id() != 0) {
    total_size += 1 + 8;
  }

  // fixed64 resource_id = 3;
  if (this->_internal_resource_id() != 0) {
    total_size += 1 + 8;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GameAssetStatusRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    GameAssetStatusRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GameAssetStatusRequest::GetClassData() const { return &_class_data_; }

void GameAssetStatusRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<GameAssetStatusRequest *>(to)->MergeFrom(
      static_cast<const GameAssetStatusRequest &>(from));
}


void GameAssetStatusRequest::MergeFrom(const GameAssetStatusRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:afterline.GameAssetStatusRequest)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_session_id() != 0) {
    _internal_set_session_id(from._internal_session_id());
  }
  if (from._internal_game_id() != 0) {
    _internal_set_game_id(from._internal_game_id());
  }
  if (from._internal_resource_id() != 0) {
    _internal_set_resource_id(from._internal_resource_id());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void GameAssetStatusRequest::CopyFrom(const GameAssetStatusRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:afterline.GameAssetStatusRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GameAssetStatusRequest::IsInitialized() const {
  return true;
}

void GameAssetStatusRequest::InternalSwap(GameAssetStatusRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(GameAssetStatusRequest, resource_id_)
      + sizeof(GameAssetStatusRequest::resource_id_)
      - PROTOBUF_FIELD_OFFSET(GameAssetStatusRequest, session_id_)>(
          reinterpret_cast<char*>(&session_id_),
          reinterpret_cast<char*>(&other->session_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata GameAssetStatusRequest::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_afterline_2fasset_2eproto_getter, &descriptor_table_afterline_2fasset_2eproto_once,
      file_level_metadata_afterline_2fasset_2eproto[3]);
}

// ===================================================================

class AssetStatusResponse::_Internal {
 public:
};

AssetStatusResponse::AssetStatusResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:afterline.AssetStatusResponse)
}
AssetStatusResponse::AssetStatusResponse(const AssetStatusResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&resource_id_, &from.resource_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&available_) -
    reinterpret_cast<char*>(&resource_id_)) + sizeof(available_));
  // @@protoc_insertion_point(copy_constructor:afterline.AssetStatusResponse)
}

inline void AssetStatusResponse::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&resource_id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&available_) -
    reinterpret_cast<char*>(&resource_id_)) + sizeof(available_));
}

AssetStatusResponse::~AssetStatusResponse() {
  // @@protoc_insertion_point(destructor:afterline.AssetStatusResponse)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void AssetStatusResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void AssetStatusResponse::ArenaDtor(void* object) {
  AssetStatusResponse* _this = reinterpret_cast< AssetStatusResponse* >(object);
  (void)_this;
}
void AssetStatusResponse::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void AssetStatusResponse::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void AssetStatusResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:afterline.AssetStatusResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&resource_id_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&available_) -
      reinterpret_cast<char*>(&resource_id_)) + sizeof(available_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AssetStatusResponse::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // fixed64 resource_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          resource_id_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      // bool available = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          available_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AssetStatusResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:afterline.AssetStatusResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // fixed64 resource_id = 1;
  if (this->_internal_resource_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFixed64ToArray(1, this->_internal_resource_id(), target);
  }

  // bool available = 2;
  if (this->_internal_available() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(2, this->_internal_available(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:afterline.AssetStatusResponse)
  return target;
}

size_t AssetStatusResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:afterline.AssetStatusResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // fixed64 resource_id = 1;
  if (this->_internal_resource_id() != 0) {
    total_size += 1 + 8;
  }

  // bool available = 2;
  if (this->_internal_available() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AssetStatusResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    AssetStatusResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AssetStatusResponse::GetClassData() const { return &_class_data_; }

void AssetStatusResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<AssetStatusResponse *>(to)->MergeFrom(
      static_cast<const AssetStatusResponse &>(from));
}


void AssetStatusResponse::MergeFrom(const AssetStatusResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:afterline.AssetStatusResponse)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_resource_id() != 0) {
    _internal_set_resource_id(from._internal_resource_id());
  }
  if (from._internal_available() != 0) {
    _internal_set_available(from._internal_available());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AssetStatusResponse::CopyFrom(const AssetStatusResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:afterline.AssetStatusResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AssetStatusResponse::IsInitialized() const {
  return true;
}

void AssetStatusResponse::InternalSwap(AssetStatusResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AssetStatusResponse, available_)
      + sizeof(AssetStatusResponse::available_)
      - PROTOBUF_FIELD_OFFSET(AssetStatusResponse, resource_id_)>(
          reinterpret_cast<char*>(&resource_id_),
          reinterpret_cast<char*>(&other->resource_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata AssetStatusResponse::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_afterline_2fasset_2eproto_getter, &descriptor_table_afterline_2fasset_2eproto_once,
      file_level_metadata_afterline_2fasset_2eproto[4]);
}

// ===================================================================

class GameAssetStatusResponse::_Internal {
 public:
};

GameAssetStatusResponse::GameAssetStatusResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:afterline.GameAssetStatusResponse)
}
GameAssetStatusResponse::GameAssetStatusResponse(const GameAssetStatusResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&game_id_, &from.game_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&available_) -
    reinterpret_cast<char*>(&game_id_)) + sizeof(available_));
  // @@protoc_insertion_point(copy_constructor:afterline.GameAssetStatusResponse)
}

inline void GameAssetStatusResponse::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&game_id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&available_) -
    reinterpret_cast<char*>(&game_id_)) + sizeof(available_));
}

GameAssetStatusResponse::~GameAssetStatusResponse() {
  // @@protoc_insertion_point(destructor:afterline.GameAssetStatusResponse)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void GameAssetStatusResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void GameAssetStatusResponse::ArenaDtor(void* object) {
  GameAssetStatusResponse* _this = reinterpret_cast< GameAssetStatusResponse* >(object);
  (void)_this;
}
void GameAssetStatusResponse::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void GameAssetStatusResponse::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void GameAssetStatusResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:afterline.GameAssetStatusResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&game_id_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&available_) -
      reinterpret_cast<char*>(&game_id_)) + sizeof(available_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GameAssetStatusResponse::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // fixed64 game_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          game_id_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      // fixed64 resource_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          resource_id_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      // bool available = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          available_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GameAssetStatusResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:afterline.GameAssetStatusResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // fixed64 game_id = 1;
  if (this->_internal_game_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFixed64ToArray(1, this->_internal_game_id(), target);
  }

  // fixed64 resource_id = 2;
  if (this->_internal_resource_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFixed64ToArray(2, this->_internal_resource_id(), target);
  }

  // bool available = 3;
  if (this->_internal_available() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(3, this->_internal_available(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:afterline.GameAssetStatusResponse)
  return target;
}

size_t GameAssetStatusResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:afterline.GameAssetStatusResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // fixed64 game_id = 1;
  if (this->_internal_game_id() != 0) {
    total_size += 1 + 8;
  }

  // fixed64 resource_id = 2;
  if (this->_internal_resource_id() != 0) {
    total_size += 1 + 8;
  }

  // bool available = 3;
  if (this->_internal_available() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GameAssetStatusResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    GameAssetStatusResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GameAssetStatusResponse::GetClassData() const { return &_class_data_; }

void GameAssetStatusResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<GameAssetStatusResponse *>(to)->MergeFrom(
      static_cast<const GameAssetStatusResponse &>(from));
}


void GameAssetStatusResponse::MergeFrom(const GameAssetStatusResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:afterline.GameAssetStatusResponse)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_game_id() != 0) {
    _internal_set_game_id(from._internal_game_id());
  }
  if (from._internal_resource_id() != 0) {
    _internal_set_resource_id(from._internal_resource_id());
  }
  if (from._internal_available() != 0) {
    _internal_set_available(from._internal_available());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void GameAssetStatusResponse::CopyFrom(const GameAssetStatusResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:afterline.GameAssetStatusResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GameAssetStatusResponse::IsInitialized() const {
  return true;
}

void GameAssetStatusResponse::InternalSwap(GameAssetStatusResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(GameAssetStatusResponse, available_)
      + sizeof(GameAssetStatusResponse::available_)
      - PROTOBUF_FIELD_OFFSET(GameAssetStatusResponse, game_id_)>(
          reinterpret_cast<char*>(&game_id_),
          reinterpret_cast<char*>(&other->game_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata GameAssetStatusResponse::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_afterline_2fasset_2eproto_getter, &descriptor_table_afterline_2fasset_2eproto_once,
      file_level_metadata_afterline_2fasset_2eproto[5]);
}

// ===================================================================

class AdminAssetStatusOverrideRequest::_Internal {
 public:
};

AdminAssetStatusOverrideRequest::AdminAssetStatusOverrideRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:afterline.AdminAssetStatusOverrideRequest)
}
AdminAssetStatusOverrideRequest::AdminAssetStatusOverrideRequest(const AdminAssetStatusOverrideRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&session_id_, &from.session_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&override_) -
    reinterpret_cast<char*>(&session_id_)) + sizeof(override_));
  // @@protoc_insertion_point(copy_constructor:afterline.AdminAssetStatusOverrideRequest)
}

inline void AdminAssetStatusOverrideRequest::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&session_id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&override_) -
    reinterpret_cast<char*>(&session_id_)) + sizeof(override_));
}

AdminAssetStatusOverrideRequest::~AdminAssetStatusOverrideRequest() {
  // @@protoc_insertion_point(destructor:afterline.AdminAssetStatusOverrideRequest)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void AdminAssetStatusOverrideRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void AdminAssetStatusOverrideRequest::ArenaDtor(void* object) {
  AdminAssetStatusOverrideRequest* _this = reinterpret_cast< AdminAssetStatusOverrideRequest* >(object);
  (void)_this;
}
void AdminAssetStatusOverrideRequest::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void AdminAssetStatusOverrideRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void AdminAssetStatusOverrideRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:afterline.AdminAssetStatusOverrideRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&session_id_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&override_) -
      reinterpret_cast<char*>(&session_id_)) + sizeof(override_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AdminAssetStatusOverrideRequest::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // fixed64 session_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          session_id_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      // bool override = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          override_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AdminAssetStatusOverrideRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:afterline.AdminAssetStatusOverrideRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // fixed64 session_id = 1;
  if (this->_internal_session_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFixed64ToArray(1, this->_internal_session_id(), target);
  }

  // bool override = 2;
  if (this->_internal_override() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(2, this->_internal_override(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:afterline.AdminAssetStatusOverrideRequest)
  return target;
}

size_t AdminAssetStatusOverrideRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:afterline.AdminAssetStatusOverrideRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // fixed64 session_id = 1;
  if (this->_internal_session_id() != 0) {
    total_size += 1 + 8;
  }

  // bool override = 2;
  if (this->_internal_override() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AdminAssetStatusOverrideRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    AdminAssetStatusOverrideRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AdminAssetStatusOverrideRequest::GetClassData() const { return &_class_data_; }

void AdminAssetStatusOverrideRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<AdminAssetStatusOverrideRequest *>(to)->MergeFrom(
      static_cast<const AdminAssetStatusOverrideRequest &>(from));
}


void AdminAssetStatusOverrideRequest::MergeFrom(const AdminAssetStatusOverrideRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:afterline.AdminAssetStatusOverrideRequest)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_session_id() != 0) {
    _internal_set_session_id(from._internal_session_id());
  }
  if (from._internal_override() != 0) {
    _internal_set_override(from._internal_override());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AdminAssetStatusOverrideRequest::CopyFrom(const AdminAssetStatusOverrideRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:afterline.AdminAssetStatusOverrideRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AdminAssetStatusOverrideRequest::IsInitialized() const {
  return true;
}

void AdminAssetStatusOverrideRequest::InternalSwap(AdminAssetStatusOverrideRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AdminAssetStatusOverrideRequest, override_)
      + sizeof(AdminAssetStatusOverrideRequest::override_)
      - PROTOBUF_FIELD_OFFSET(AdminAssetStatusOverrideRequest, session_id_)>(
          reinterpret_cast<char*>(&session_id_),
          reinterpret_cast<char*>(&other->session_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata AdminAssetStatusOverrideRequest::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_afterline_2fasset_2eproto_getter, &descriptor_table_afterline_2fasset_2eproto_once,
      file_level_metadata_afterline_2fasset_2eproto[6]);
}

// ===================================================================

class AdminAssetStatusOverrideResponse::_Internal {
 public:
};

AdminAssetStatusOverrideResponse::AdminAssetStatusOverrideResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:afterline.AdminAssetStatusOverrideResponse)
}
AdminAssetStatusOverrideResponse::AdminAssetStatusOverrideResponse(const AdminAssetStatusOverrideResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  succeeded_ = from.succeeded_;
  // @@protoc_insertion_point(copy_constructor:afterline.AdminAssetStatusOverrideResponse)
}

inline void AdminAssetStatusOverrideResponse::SharedCtor() {
succeeded_ = false;
}

AdminAssetStatusOverrideResponse::~AdminAssetStatusOverrideResponse() {
  // @@protoc_insertion_point(destructor:afterline.AdminAssetStatusOverrideResponse)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void AdminAssetStatusOverrideResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void AdminAssetStatusOverrideResponse::ArenaDtor(void* object) {
  AdminAssetStatusOverrideResponse* _this = reinterpret_cast< AdminAssetStatusOverrideResponse* >(object);
  (void)_this;
}
void AdminAssetStatusOverrideResponse::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void AdminAssetStatusOverrideResponse::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void AdminAssetStatusOverrideResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:afterline.AdminAssetStatusOverrideResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  succeeded_ = false;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* AdminAssetStatusOverrideResponse::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bool succeeded = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          succeeded_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AdminAssetStatusOverrideResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:afterline.AdminAssetStatusOverrideResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bool succeeded = 1;
  if (this->_internal_succeeded() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(1, this->_internal_succeeded(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:afterline.AdminAssetStatusOverrideResponse)
  return target;
}

size_t AdminAssetStatusOverrideResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:afterline.AdminAssetStatusOverrideResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bool succeeded = 1;
  if (this->_internal_succeeded() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData AdminAssetStatusOverrideResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    AdminAssetStatusOverrideResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*AdminAssetStatusOverrideResponse::GetClassData() const { return &_class_data_; }

void AdminAssetStatusOverrideResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<AdminAssetStatusOverrideResponse *>(to)->MergeFrom(
      static_cast<const AdminAssetStatusOverrideResponse &>(from));
}


void AdminAssetStatusOverrideResponse::MergeFrom(const AdminAssetStatusOverrideResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:afterline.AdminAssetStatusOverrideResponse)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_succeeded() != 0) {
    _internal_set_succeeded(from._internal_succeeded());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void AdminAssetStatusOverrideResponse::CopyFrom(const AdminAssetStatusOverrideResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:afterline.AdminAssetStatusOverrideResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AdminAssetStatusOverrideResponse::IsInitialized() const {
  return true;
}

void AdminAssetStatusOverrideResponse::InternalSwap(AdminAssetStatusOverrideResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(succeeded_, other->succeeded_);
}

::PROTOBUF_NAMESPACE_ID::Metadata AdminAssetStatusOverrideResponse::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_afterline_2fasset_2eproto_getter, &descriptor_table_afterline_2fasset_2eproto_once,
      file_level_metadata_afterline_2fasset_2eproto[7]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace afterline
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::afterline::IconSetInfo_IconInfo* Arena::CreateMaybeMessage< ::afterline::IconSetInfo_IconInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::afterline::IconSetInfo_IconInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::afterline::IconSetInfo* Arena::CreateMaybeMessage< ::afterline::IconSetInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::afterline::IconSetInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::afterline::AssetStatusRequest* Arena::CreateMaybeMessage< ::afterline::AssetStatusRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::afterline::AssetStatusRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::afterline::GameAssetStatusRequest* Arena::CreateMaybeMessage< ::afterline::GameAssetStatusRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::afterline::GameAssetStatusRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::afterline::AssetStatusResponse* Arena::CreateMaybeMessage< ::afterline::AssetStatusResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::afterline::AssetStatusResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::afterline::GameAssetStatusResponse* Arena::CreateMaybeMessage< ::afterline::GameAssetStatusResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::afterline::GameAssetStatusResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::afterline::AdminAssetStatusOverrideRequest* Arena::CreateMaybeMessage< ::afterline::AdminAssetStatusOverrideRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::afterline::AdminAssetStatusOverrideRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::afterline::AdminAssetStatusOverrideResponse* Arena::CreateMaybeMessage< ::afterline::AdminAssetStatusOverrideResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::afterline::AdminAssetStatusOverrideResponse >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
