// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: afterline/system.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_afterline_2fsystem_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_afterline_2fsystem_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "afterline/asset.pb.h"
#include "afterline/game.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_afterline_2fsystem_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_afterline_2fsystem_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[25]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_afterline_2fsystem_2eproto;
namespace afterline {
class BlockUserRequest;
struct BlockUserRequestDefaultTypeInternal;
extern BlockUserRequestDefaultTypeInternal _BlockUserRequest_default_instance_;
class BlockUserResponse;
struct BlockUserResponseDefaultTypeInternal;
extern BlockUserResponseDefaultTypeInternal _BlockUserResponse_default_instance_;
class CancelFederatedLogin;
struct CancelFederatedLoginDefaultTypeInternal;
extern CancelFederatedLoginDefaultTypeInternal _CancelFederatedLogin_default_instance_;
class Connect;
struct ConnectDefaultTypeInternal;
extern ConnectDefaultTypeInternal _Connect_default_instance_;
class Disconnect;
struct DisconnectDefaultTypeInternal;
extern DisconnectDefaultTypeInternal _Disconnect_default_instance_;
class FederatedLogOutRequest;
struct FederatedLogOutRequestDefaultTypeInternal;
extern FederatedLogOutRequestDefaultTypeInternal _FederatedLogOutRequest_default_instance_;
class FederatedLogOutResponse;
struct FederatedLogOutResponseDefaultTypeInternal;
extern FederatedLogOutResponseDefaultTypeInternal _FederatedLogOutResponse_default_instance_;
class FederatedLoginComplete;
struct FederatedLoginCompleteDefaultTypeInternal;
extern FederatedLoginCompleteDefaultTypeInternal _FederatedLoginComplete_default_instance_;
class FederatedLoginRequest;
struct FederatedLoginRequestDefaultTypeInternal;
extern FederatedLoginRequestDefaultTypeInternal _FederatedLoginRequest_default_instance_;
class FederatedLoginResponse;
struct FederatedLoginResponseDefaultTypeInternal;
extern FederatedLoginResponseDefaultTypeInternal _FederatedLoginResponse_default_instance_;
class FederatedLoginTimeout;
struct FederatedLoginTimeoutDefaultTypeInternal;
extern FederatedLoginTimeoutDefaultTypeInternal _FederatedLoginTimeout_default_instance_;
class FindUserRequest;
struct FindUserRequestDefaultTypeInternal;
extern FindUserRequestDefaultTypeInternal _FindUserRequest_default_instance_;
class FindUserResponse;
struct FindUserResponseDefaultTypeInternal;
extern FindUserResponseDefaultTypeInternal _FindUserResponse_default_instance_;
class FriendUserRequest;
struct FriendUserRequestDefaultTypeInternal;
extern FriendUserRequestDefaultTypeInternal _FriendUserRequest_default_instance_;
class FriendUserResponse;
struct FriendUserResponseDefaultTypeInternal;
extern FriendUserResponseDefaultTypeInternal _FriendUserResponse_default_instance_;
class GetPublicUserInfoRequest;
struct GetPublicUserInfoRequestDefaultTypeInternal;
extern GetPublicUserInfoRequestDefaultTypeInternal _GetPublicUserInfoRequest_default_instance_;
class GetPublicUserInfoResponse;
struct GetPublicUserInfoResponseDefaultTypeInternal;
extern GetPublicUserInfoResponseDefaultTypeInternal _GetPublicUserInfoResponse_default_instance_;
class GetPublicUserInfoResponse_PublicUserInfo;
struct GetPublicUserInfoResponse_PublicUserInfoDefaultTypeInternal;
extern GetPublicUserInfoResponse_PublicUserInfoDefaultTypeInternal _GetPublicUserInfoResponse_PublicUserInfo_default_instance_;
class GetUserIDRequest;
struct GetUserIDRequestDefaultTypeInternal;
extern GetUserIDRequestDefaultTypeInternal _GetUserIDRequest_default_instance_;
class GetUserIDResponse;
struct GetUserIDResponseDefaultTypeInternal;
extern GetUserIDResponseDefaultTypeInternal _GetUserIDResponse_default_instance_;
class GetUserStatusRequest;
struct GetUserStatusRequestDefaultTypeInternal;
extern GetUserStatusRequestDefaultTypeInternal _GetUserStatusRequest_default_instance_;
class UnFriendUserRequest;
struct UnFriendUserRequestDefaultTypeInternal;
extern UnFriendUserRequestDefaultTypeInternal _UnFriendUserRequest_default_instance_;
class UnFriendUserResponse;
struct UnFriendUserResponseDefaultTypeInternal;
extern UnFriendUserResponseDefaultTypeInternal _UnFriendUserResponse_default_instance_;
class ValidateSessionIdRequest;
struct ValidateSessionIdRequestDefaultTypeInternal;
extern ValidateSessionIdRequestDefaultTypeInternal _ValidateSessionIdRequest_default_instance_;
class ValidateSessionIdResponse;
struct ValidateSessionIdResponseDefaultTypeInternal;
extern ValidateSessionIdResponseDefaultTypeInternal _ValidateSessionIdResponse_default_instance_;
}  // namespace afterline
PROTOBUF_NAMESPACE_OPEN
template<> ::afterline::BlockUserRequest* Arena::CreateMaybeMessage<::afterline::BlockUserRequest>(Arena*);
template<> ::afterline::BlockUserResponse* Arena::CreateMaybeMessage<::afterline::BlockUserResponse>(Arena*);
template<> ::afterline::CancelFederatedLogin* Arena::CreateMaybeMessage<::afterline::CancelFederatedLogin>(Arena*);
template<> ::afterline::Connect* Arena::CreateMaybeMessage<::afterline::Connect>(Arena*);
template<> ::afterline::Disconnect* Arena::CreateMaybeMessage<::afterline::Disconnect>(Arena*);
template<> ::afterline::FederatedLogOutRequest* Arena::CreateMaybeMessage<::afterline::FederatedLogOutRequest>(Arena*);
template<> ::afterline::FederatedLogOutResponse* Arena::CreateMaybeMessage<::afterline::FederatedLogOutResponse>(Arena*);
template<> ::afterline::FederatedLoginComplete* Arena::CreateMaybeMessage<::afterline::FederatedLoginComplete>(Arena*);
template<> ::afterline::FederatedLoginRequest* Arena::CreateMaybeMessage<::afterline::FederatedLoginRequest>(Arena*);
template<> ::afterline::FederatedLoginResponse* Arena::CreateMaybeMessage<::afterline::FederatedLoginResponse>(Arena*);
template<> ::afterline::FederatedLoginTimeout* Arena::CreateMaybeMessage<::afterline::FederatedLoginTimeout>(Arena*);
template<> ::afterline::FindUserRequest* Arena::CreateMaybeMessage<::afterline::FindUserRequest>(Arena*);
template<> ::afterline::FindUserResponse* Arena::CreateMaybeMessage<::afterline::FindUserResponse>(Arena*);
template<> ::afterline::FriendUserRequest* Arena::CreateMaybeMessage<::afterline::FriendUserRequest>(Arena*);
template<> ::afterline::FriendUserResponse* Arena::CreateMaybeMessage<::afterline::FriendUserResponse>(Arena*);
template<> ::afterline::GetPublicUserInfoRequest* Arena::CreateMaybeMessage<::afterline::GetPublicUserInfoRequest>(Arena*);
template<> ::afterline::GetPublicUserInfoResponse* Arena::CreateMaybeMessage<::afterline::GetPublicUserInfoResponse>(Arena*);
template<> ::afterline::GetPublicUserInfoResponse_PublicUserInfo* Arena::CreateMaybeMessage<::afterline::GetPublicUserInfoResponse_PublicUserInfo>(Arena*);
template<> ::afterline::GetUserIDRequest* Arena::CreateMaybeMessage<::afterline::GetUserIDRequest>(Arena*);
template<> ::afterline::GetUserIDResponse* Arena::CreateMaybeMessage<::afterline::GetUserIDResponse>(Arena*);
template<> ::afterline::GetUserStatusRequest* Arena::CreateMaybeMessage<::afterline::GetUserStatusRequest>(Arena*);
template<> ::afterline::UnFriendUserRequest* Arena::CreateMaybeMessage<::afterline::UnFriendUserRequest>(Arena*);
template<> ::afterline::UnFriendUserResponse* Arena::CreateMaybeMessage<::afterline::UnFriendUserResponse>(Arena*);
template<> ::afterline::ValidateSessionIdRequest* Arena::CreateMaybeMessage<::afterline::ValidateSessionIdRequest>(Arena*);
template<> ::afterline::ValidateSessionIdResponse* Arena::CreateMaybeMessage<::afterline::ValidateSessionIdResponse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace afterline {

enum GetPublicUserInfoResponse_PublicUserInfo_Status : int {
  GetPublicUserInfoResponse_PublicUserInfo_Status_OFFLINE = 0,
  GetPublicUserInfoResponse_PublicUserInfo_Status_ONLINE = 1,
  GetPublicUserInfoResponse_PublicUserInfo_Status_IN_GAME = 2,
  GetPublicUserInfoResponse_PublicUserInfo_Status_GetPublicUserInfoResponse_PublicUserInfo_Status_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  GetPublicUserInfoResponse_PublicUserInfo_Status_GetPublicUserInfoResponse_PublicUserInfo_Status_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool GetPublicUserInfoResponse_PublicUserInfo_Status_IsValid(int value);
constexpr GetPublicUserInfoResponse_PublicUserInfo_Status GetPublicUserInfoResponse_PublicUserInfo_Status_Status_MIN = GetPublicUserInfoResponse_PublicUserInfo_Status_OFFLINE;
constexpr GetPublicUserInfoResponse_PublicUserInfo_Status GetPublicUserInfoResponse_PublicUserInfo_Status_Status_MAX = GetPublicUserInfoResponse_PublicUserInfo_Status_IN_GAME;
constexpr int GetPublicUserInfoResponse_PublicUserInfo_Status_Status_ARRAYSIZE = GetPublicUserInfoResponse_PublicUserInfo_Status_Status_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* GetPublicUserInfoResponse_PublicUserInfo_Status_descriptor();
template<typename T>
inline const std::string& GetPublicUserInfoResponse_PublicUserInfo_Status_Name(T enum_t_value) {
  static_assert(::std::is_same<T, GetPublicUserInfoResponse_PublicUserInfo_Status>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function GetPublicUserInfoResponse_PublicUserInfo_Status_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    GetPublicUserInfoResponse_PublicUserInfo_Status_descriptor(), enum_t_value);
}
inline bool GetPublicUserInfoResponse_PublicUserInfo_Status_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, GetPublicUserInfoResponse_PublicUserInfo_Status* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<GetPublicUserInfoResponse_PublicUserInfo_Status>(
    GetPublicUserInfoResponse_PublicUserInfo_Status_descriptor(), name, value);
}
enum FriendUserResponse_Status : int {
  FriendUserResponse_Status_PENDING = 0,
  FriendUserResponse_Status_BLOCKED = 1,
  FriendUserResponse_Status_ACCEPTED = 2,
  FriendUserResponse_Status_FriendUserResponse_Status_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  FriendUserResponse_Status_FriendUserResponse_Status_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool FriendUserResponse_Status_IsValid(int value);
constexpr FriendUserResponse_Status FriendUserResponse_Status_Status_MIN = FriendUserResponse_Status_PENDING;
constexpr FriendUserResponse_Status FriendUserResponse_Status_Status_MAX = FriendUserResponse_Status_ACCEPTED;
constexpr int FriendUserResponse_Status_Status_ARRAYSIZE = FriendUserResponse_Status_Status_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* FriendUserResponse_Status_descriptor();
template<typename T>
inline const std::string& FriendUserResponse_Status_Name(T enum_t_value) {
  static_assert(::std::is_same<T, FriendUserResponse_Status>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function FriendUserResponse_Status_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    FriendUserResponse_Status_descriptor(), enum_t_value);
}
inline bool FriendUserResponse_Status_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, FriendUserResponse_Status* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<FriendUserResponse_Status>(
    FriendUserResponse_Status_descriptor(), name, value);
}
// ===================================================================

class FederatedLoginRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:afterline.FederatedLoginRequest) */ {
 public:
  inline FederatedLoginRequest() : FederatedLoginRequest(nullptr) {}
  ~FederatedLoginRequest() override;
  explicit constexpr FederatedLoginRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FederatedLoginRequest(const FederatedLoginRequest& from);
  FederatedLoginRequest(FederatedLoginRequest&& from) noexcept
    : FederatedLoginRequest() {
    *this = ::std::move(from);
  }

  inline FederatedLoginRequest& operator=(const FederatedLoginRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline FederatedLoginRequest& operator=(FederatedLoginRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FederatedLoginRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const FederatedLoginRequest* internal_default_instance() {
    return reinterpret_cast<const FederatedLoginRequest*>(
               &_FederatedLoginRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(FederatedLoginRequest& a, FederatedLoginRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(FederatedLoginRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FederatedLoginRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FederatedLoginRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FederatedLoginRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FederatedLoginRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const FederatedLoginRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FederatedLoginRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "afterline.FederatedLoginRequest";
  }
  protected:
  explicit FederatedLoginRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRememberMeFieldNumber = 1,
  };
  // bool remember_me = 1;
  void clear_remember_me();
  bool remember_me() const;
  void set_remember_me(bool value);
  private:
  bool _internal_remember_me() const;
  void _internal_set_remember_me(bool value);
  public:

  // @@protoc_insertion_point(class_scope:afterline.FederatedLoginRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  bool remember_me_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_afterline_2fsystem_2eproto;
};
// -------------------------------------------------------------------

class FederatedLoginResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:afterline.FederatedLoginResponse) */ {
 public:
  inline FederatedLoginResponse() : FederatedLoginResponse(nullptr) {}
  ~FederatedLoginResponse() override;
  explicit constexpr FederatedLoginResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FederatedLoginResponse(const FederatedLoginResponse& from);
  FederatedLoginResponse(FederatedLoginResponse&& from) noexcept
    : FederatedLoginResponse() {
    *this = ::std::move(from);
  }

  inline FederatedLoginResponse& operator=(const FederatedLoginResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline FederatedLoginResponse& operator=(FederatedLoginResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FederatedLoginResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const FederatedLoginResponse* internal_default_instance() {
    return reinterpret_cast<const FederatedLoginResponse*>(
               &_FederatedLoginResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(FederatedLoginResponse& a, FederatedLoginResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(FederatedLoginResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FederatedLoginResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FederatedLoginResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FederatedLoginResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FederatedLoginResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const FederatedLoginResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FederatedLoginResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "afterline.FederatedLoginResponse";
  }
  protected:
  explicit FederatedLoginResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLinkFieldNumber = 1,
  };
  // string link = 1;
  void clear_link();
  const std::string& link() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_link(ArgT0&& arg0, ArgT... args);
  std::string* mutable_link();
  PROTOBUF_NODISCARD std::string* release_link();
  void set_allocated_link(std::string* link);
  private:
  const std::string& _internal_link() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_link(const std::string& value);
  std::string* _internal_mutable_link();
  public:

  // @@protoc_insertion_point(class_scope:afterline.FederatedLoginResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr link_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_afterline_2fsystem_2eproto;
};
// -------------------------------------------------------------------

class FederatedLoginComplete final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:afterline.FederatedLoginComplete) */ {
 public:
  inline FederatedLoginComplete() : FederatedLoginComplete(nullptr) {}
  ~FederatedLoginComplete() override;
  explicit constexpr FederatedLoginComplete(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FederatedLoginComplete(const FederatedLoginComplete& from);
  FederatedLoginComplete(FederatedLoginComplete&& from) noexcept
    : FederatedLoginComplete() {
    *this = ::std::move(from);
  }

  inline FederatedLoginComplete& operator=(const FederatedLoginComplete& from) {
    CopyFrom(from);
    return *this;
  }
  inline FederatedLoginComplete& operator=(FederatedLoginComplete&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FederatedLoginComplete& default_instance() {
    return *internal_default_instance();
  }
  static inline const FederatedLoginComplete* internal_default_instance() {
    return reinterpret_cast<const FederatedLoginComplete*>(
               &_FederatedLoginComplete_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(FederatedLoginComplete& a, FederatedLoginComplete& b) {
    a.Swap(&b);
  }
  inline void Swap(FederatedLoginComplete* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FederatedLoginComplete* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FederatedLoginComplete* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FederatedLoginComplete>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FederatedLoginComplete& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const FederatedLoginComplete& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FederatedLoginComplete* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "afterline.FederatedLoginComplete";
  }
  protected:
  explicit FederatedLoginComplete(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserEmailFieldNumber = 2,
    kUserNameFieldNumber = 3,
    kClientSessionIdFieldNumber = 1,
  };
  // string user_email = 2;
  void clear_user_email();
  const std::string& user_email() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_email(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_email();
  PROTOBUF_NODISCARD std::string* release_user_email();
  void set_allocated_user_email(std::string* user_email);
  private:
  const std::string& _internal_user_email() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_email(const std::string& value);
  std::string* _internal_mutable_user_email();
  public:

  // string user_name = 3;
  void clear_user_name();
  const std::string& user_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_name();
  PROTOBUF_NODISCARD std::string* release_user_name();
  void set_allocated_user_name(std::string* user_name);
  private:
  const std::string& _internal_user_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_name(const std::string& value);
  std::string* _internal_mutable_user_name();
  public:

  // fixed64 client_session_id = 1;
  void clear_client_session_id();
  uint64_t client_session_id() const;
  void set_client_session_id(uint64_t value);
  private:
  uint64_t _internal_client_session_id() const;
  void _internal_set_client_session_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:afterline.FederatedLoginComplete)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_email_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_name_;
  uint64_t client_session_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_afterline_2fsystem_2eproto;
};
// -------------------------------------------------------------------

class FederatedLoginTimeout final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:afterline.FederatedLoginTimeout) */ {
 public:
  inline FederatedLoginTimeout() : FederatedLoginTimeout(nullptr) {}
  explicit constexpr FederatedLoginTimeout(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FederatedLoginTimeout(const FederatedLoginTimeout& from);
  FederatedLoginTimeout(FederatedLoginTimeout&& from) noexcept
    : FederatedLoginTimeout() {
    *this = ::std::move(from);
  }

  inline FederatedLoginTimeout& operator=(const FederatedLoginTimeout& from) {
    CopyFrom(from);
    return *this;
  }
  inline FederatedLoginTimeout& operator=(FederatedLoginTimeout&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FederatedLoginTimeout& default_instance() {
    return *internal_default_instance();
  }
  static inline const FederatedLoginTimeout* internal_default_instance() {
    return reinterpret_cast<const FederatedLoginTimeout*>(
               &_FederatedLoginTimeout_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(FederatedLoginTimeout& a, FederatedLoginTimeout& b) {
    a.Swap(&b);
  }
  inline void Swap(FederatedLoginTimeout* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FederatedLoginTimeout* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FederatedLoginTimeout* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FederatedLoginTimeout>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const FederatedLoginTimeout& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const FederatedLoginTimeout& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "afterline.FederatedLoginTimeout";
  }
  protected:
  explicit FederatedLoginTimeout(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:afterline.FederatedLoginTimeout)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_afterline_2fsystem_2eproto;
};
// -------------------------------------------------------------------

class CancelFederatedLogin final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:afterline.CancelFederatedLogin) */ {
 public:
  inline CancelFederatedLogin() : CancelFederatedLogin(nullptr) {}
  explicit constexpr CancelFederatedLogin(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CancelFederatedLogin(const CancelFederatedLogin& from);
  CancelFederatedLogin(CancelFederatedLogin&& from) noexcept
    : CancelFederatedLogin() {
    *this = ::std::move(from);
  }

  inline CancelFederatedLogin& operator=(const CancelFederatedLogin& from) {
    CopyFrom(from);
    return *this;
  }
  inline CancelFederatedLogin& operator=(CancelFederatedLogin&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CancelFederatedLogin& default_instance() {
    return *internal_default_instance();
  }
  static inline const CancelFederatedLogin* internal_default_instance() {
    return reinterpret_cast<const CancelFederatedLogin*>(
               &_CancelFederatedLogin_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(CancelFederatedLogin& a, CancelFederatedLogin& b) {
    a.Swap(&b);
  }
  inline void Swap(CancelFederatedLogin* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CancelFederatedLogin* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CancelFederatedLogin* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CancelFederatedLogin>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const CancelFederatedLogin& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const CancelFederatedLogin& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "afterline.CancelFederatedLogin";
  }
  protected:
  explicit CancelFederatedLogin(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:afterline.CancelFederatedLogin)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_afterline_2fsystem_2eproto;
};
// -------------------------------------------------------------------

class FederatedLogOutRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:afterline.FederatedLogOutRequest) */ {
 public:
  inline FederatedLogOutRequest() : FederatedLogOutRequest(nullptr) {}
  ~FederatedLogOutRequest() override;
  explicit constexpr FederatedLogOutRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FederatedLogOutRequest(const FederatedLogOutRequest& from);
  FederatedLogOutRequest(FederatedLogOutRequest&& from) noexcept
    : FederatedLogOutRequest() {
    *this = ::std::move(from);
  }

  inline FederatedLogOutRequest& operator=(const FederatedLogOutRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline FederatedLogOutRequest& operator=(FederatedLogOutRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FederatedLogOutRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const FederatedLogOutRequest* internal_default_instance() {
    return reinterpret_cast<const FederatedLogOutRequest*>(
               &_FederatedLogOutRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(FederatedLogOutRequest& a, FederatedLogOutRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(FederatedLogOutRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FederatedLogOutRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FederatedLogOutRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FederatedLogOutRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FederatedLogOutRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const FederatedLogOutRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FederatedLogOutRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "afterline.FederatedLogOutRequest";
  }
  protected:
  explicit FederatedLogOutRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClientSessionIdFieldNumber = 1,
  };
  // fixed64 client_session_id = 1;
  void clear_client_session_id();
  uint64_t client_session_id() const;
  void set_client_session_id(uint64_t value);
  private:
  uint64_t _internal_client_session_id() const;
  void _internal_set_client_session_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:afterline.FederatedLogOutRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint64_t client_session_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_afterline_2fsystem_2eproto;
};
// -------------------------------------------------------------------

class FederatedLogOutResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:afterline.FederatedLogOutResponse) */ {
 public:
  inline FederatedLogOutResponse() : FederatedLogOutResponse(nullptr) {}
  ~FederatedLogOutResponse() override;
  explicit constexpr FederatedLogOutResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FederatedLogOutResponse(const FederatedLogOutResponse& from);
  FederatedLogOutResponse(FederatedLogOutResponse&& from) noexcept
    : FederatedLogOutResponse() {
    *this = ::std::move(from);
  }

  inline FederatedLogOutResponse& operator=(const FederatedLogOutResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline FederatedLogOutResponse& operator=(FederatedLogOutResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FederatedLogOutResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const FederatedLogOutResponse* internal_default_instance() {
    return reinterpret_cast<const FederatedLogOutResponse*>(
               &_FederatedLogOutResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(FederatedLogOutResponse& a, FederatedLogOutResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(FederatedLogOutResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FederatedLogOutResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FederatedLogOutResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FederatedLogOutResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FederatedLogOutResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const FederatedLogOutResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FederatedLogOutResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "afterline.FederatedLogOutResponse";
  }
  protected:
  explicit FederatedLogOutResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSucceededFieldNumber = 1,
  };
  // bool succeeded = 1;
  void clear_succeeded();
  bool succeeded() const;
  void set_succeeded(bool value);
  private:
  bool _internal_succeeded() const;
  void _internal_set_succeeded(bool value);
  public:

  // @@protoc_insertion_point(class_scope:afterline.FederatedLogOutResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  bool succeeded_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_afterline_2fsystem_2eproto;
};
// -------------------------------------------------------------------

class ValidateSessionIdRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:afterline.ValidateSessionIdRequest) */ {
 public:
  inline ValidateSessionIdRequest() : ValidateSessionIdRequest(nullptr) {}
  ~ValidateSessionIdRequest() override;
  explicit constexpr ValidateSessionIdRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ValidateSessionIdRequest(const ValidateSessionIdRequest& from);
  ValidateSessionIdRequest(ValidateSessionIdRequest&& from) noexcept
    : ValidateSessionIdRequest() {
    *this = ::std::move(from);
  }

  inline ValidateSessionIdRequest& operator=(const ValidateSessionIdRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ValidateSessionIdRequest& operator=(ValidateSessionIdRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ValidateSessionIdRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ValidateSessionIdRequest* internal_default_instance() {
    return reinterpret_cast<const ValidateSessionIdRequest*>(
               &_ValidateSessionIdRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(ValidateSessionIdRequest& a, ValidateSessionIdRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ValidateSessionIdRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ValidateSessionIdRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ValidateSessionIdRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ValidateSessionIdRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ValidateSessionIdRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ValidateSessionIdRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ValidateSessionIdRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "afterline.ValidateSessionIdRequest";
  }
  protected:
  explicit ValidateSessionIdRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClientSessionIdFieldNumber = 1,
  };
  // fixed64 client_session_id = 1;
  void clear_client_session_id();
  uint64_t client_session_id() const;
  void set_client_session_id(uint64_t value);
  private:
  uint64_t _internal_client_session_id() const;
  void _internal_set_client_session_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:afterline.ValidateSessionIdRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint64_t client_session_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_afterline_2fsystem_2eproto;
};
// -------------------------------------------------------------------

class ValidateSessionIdResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:afterline.ValidateSessionIdResponse) */ {
 public:
  inline ValidateSessionIdResponse() : ValidateSessionIdResponse(nullptr) {}
  ~ValidateSessionIdResponse() override;
  explicit constexpr ValidateSessionIdResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ValidateSessionIdResponse(const ValidateSessionIdResponse& from);
  ValidateSessionIdResponse(ValidateSessionIdResponse&& from) noexcept
    : ValidateSessionIdResponse() {
    *this = ::std::move(from);
  }

  inline ValidateSessionIdResponse& operator=(const ValidateSessionIdResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ValidateSessionIdResponse& operator=(ValidateSessionIdResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ValidateSessionIdResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ValidateSessionIdResponse* internal_default_instance() {
    return reinterpret_cast<const ValidateSessionIdResponse*>(
               &_ValidateSessionIdResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(ValidateSessionIdResponse& a, ValidateSessionIdResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ValidateSessionIdResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ValidateSessionIdResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ValidateSessionIdResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ValidateSessionIdResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ValidateSessionIdResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ValidateSessionIdResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ValidateSessionIdResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "afterline.ValidateSessionIdResponse";
  }
  protected:
  explicit ValidateSessionIdResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValidFieldNumber = 1,
  };
  // bool valid = 1;
  void clear_valid();
  bool valid() const;
  void set_valid(bool value);
  private:
  bool _internal_valid() const;
  void _internal_set_valid(bool value);
  public:

  // @@protoc_insertion_point(class_scope:afterline.ValidateSessionIdResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  bool valid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_afterline_2fsystem_2eproto;
};
// -------------------------------------------------------------------

class Disconnect final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:afterline.Disconnect) */ {
 public:
  inline Disconnect() : Disconnect(nullptr) {}
  ~Disconnect() override;
  explicit constexpr Disconnect(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Disconnect(const Disconnect& from);
  Disconnect(Disconnect&& from) noexcept
    : Disconnect() {
    *this = ::std::move(from);
  }

  inline Disconnect& operator=(const Disconnect& from) {
    CopyFrom(from);
    return *this;
  }
  inline Disconnect& operator=(Disconnect&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Disconnect& default_instance() {
    return *internal_default_instance();
  }
  static inline const Disconnect* internal_default_instance() {
    return reinterpret_cast<const Disconnect*>(
               &_Disconnect_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(Disconnect& a, Disconnect& b) {
    a.Swap(&b);
  }
  inline void Swap(Disconnect* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Disconnect* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Disconnect* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Disconnect>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Disconnect& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Disconnect& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Disconnect* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "afterline.Disconnect";
  }
  protected:
  explicit Disconnect(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSessionIdFieldNumber = 1,
  };
  // fixed64 session_id = 1;
  void clear_session_id();
  uint64_t session_id() const;
  void set_session_id(uint64_t value);
  private:
  uint64_t _internal_session_id() const;
  void _internal_set_session_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:afterline.Disconnect)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint64_t session_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_afterline_2fsystem_2eproto;
};
// -------------------------------------------------------------------

class Connect final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:afterline.Connect) */ {
 public:
  inline Connect() : Connect(nullptr) {}
  ~Connect() override;
  explicit constexpr Connect(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Connect(const Connect& from);
  Connect(Connect&& from) noexcept
    : Connect() {
    *this = ::std::move(from);
  }

  inline Connect& operator=(const Connect& from) {
    CopyFrom(from);
    return *this;
  }
  inline Connect& operator=(Connect&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Connect& default_instance() {
    return *internal_default_instance();
  }
  static inline const Connect* internal_default_instance() {
    return reinterpret_cast<const Connect*>(
               &_Connect_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(Connect& a, Connect& b) {
    a.Swap(&b);
  }
  inline void Swap(Connect* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Connect* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Connect* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Connect>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Connect& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Connect& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Connect* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "afterline.Connect";
  }
  protected:
  explicit Connect(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSessionIdFieldNumber = 1,
  };
  // optional fixed64 session_id = 1;
  bool has_session_id() const;
  private:
  bool _internal_has_session_id() const;
  public:
  void clear_session_id();
  uint64_t session_id() const;
  void set_session_id(uint64_t value);
  private:
  uint64_t _internal_session_id() const;
  void _internal_set_session_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:afterline.Connect)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint64_t session_id_;
  friend struct ::TableStruct_afterline_2fsystem_2eproto;
};
// -------------------------------------------------------------------

class GetUserStatusRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:afterline.GetUserStatusRequest) */ {
 public:
  inline GetUserStatusRequest() : GetUserStatusRequest(nullptr) {}
  ~GetUserStatusRequest() override;
  explicit constexpr GetUserStatusRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetUserStatusRequest(const GetUserStatusRequest& from);
  GetUserStatusRequest(GetUserStatusRequest&& from) noexcept
    : GetUserStatusRequest() {
    *this = ::std::move(from);
  }

  inline GetUserStatusRequest& operator=(const GetUserStatusRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetUserStatusRequest& operator=(GetUserStatusRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetUserStatusRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetUserStatusRequest* internal_default_instance() {
    return reinterpret_cast<const GetUserStatusRequest*>(
               &_GetUserStatusRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(GetUserStatusRequest& a, GetUserStatusRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetUserStatusRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetUserStatusRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetUserStatusRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetUserStatusRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetUserStatusRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetUserStatusRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetUserStatusRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "afterline.GetUserStatusRequest";
  }
  protected:
  explicit GetUserStatusRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSessionIdFieldNumber = 1,
    kUserIdFieldNumber = 2,
    kAvailableFieldNumber = 3,
  };
  // fixed64 session_id = 1;
  void clear_session_id();
  uint64_t session_id() const;
  void set_session_id(uint64_t value);
  private:
  uint64_t _internal_session_id() const;
  void _internal_set_session_id(uint64_t value);
  public:

  // fixed64 user_id = 2;
  void clear_user_id();
  uint64_t user_id() const;
  void set_user_id(uint64_t value);
  private:
  uint64_t _internal_user_id() const;
  void _internal_set_user_id(uint64_t value);
  public:

  // bool available = 3;
  void clear_available();
  bool available() const;
  void set_available(bool value);
  private:
  bool _internal_available() const;
  void _internal_set_available(bool value);
  public:

  // @@protoc_insertion_point(class_scope:afterline.GetUserStatusRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint64_t session_id_;
  uint64_t user_id_;
  bool available_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_afterline_2fsystem_2eproto;
};
// -------------------------------------------------------------------

class GetPublicUserInfoRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:afterline.GetPublicUserInfoRequest) */ {
 public:
  inline GetPublicUserInfoRequest() : GetPublicUserInfoRequest(nullptr) {}
  ~GetPublicUserInfoRequest() override;
  explicit constexpr GetPublicUserInfoRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetPublicUserInfoRequest(const GetPublicUserInfoRequest& from);
  GetPublicUserInfoRequest(GetPublicUserInfoRequest&& from) noexcept
    : GetPublicUserInfoRequest() {
    *this = ::std::move(from);
  }

  inline GetPublicUserInfoRequest& operator=(const GetPublicUserInfoRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetPublicUserInfoRequest& operator=(GetPublicUserInfoRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetPublicUserInfoRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetPublicUserInfoRequest* internal_default_instance() {
    return reinterpret_cast<const GetPublicUserInfoRequest*>(
               &_GetPublicUserInfoRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(GetPublicUserInfoRequest& a, GetPublicUserInfoRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetPublicUserInfoRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetPublicUserInfoRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetPublicUserInfoRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetPublicUserInfoRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetPublicUserInfoRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetPublicUserInfoRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetPublicUserInfoRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "afterline.GetPublicUserInfoRequest";
  }
  protected:
  explicit GetPublicUserInfoRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSessionIdFieldNumber = 1,
    kUserIdFieldNumber = 2,
  };
  // fixed64 session_id = 1;
  void clear_session_id();
  uint64_t session_id() const;
  void set_session_id(uint64_t value);
  private:
  uint64_t _internal_session_id() const;
  void _internal_set_session_id(uint64_t value);
  public:

  // fixed64 user_id = 2;
  void clear_user_id();
  uint64_t user_id() const;
  void set_user_id(uint64_t value);
  private:
  uint64_t _internal_user_id() const;
  void _internal_set_user_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:afterline.GetPublicUserInfoRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint64_t session_id_;
  uint64_t user_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_afterline_2fsystem_2eproto;
};
// -------------------------------------------------------------------

class GetPublicUserInfoResponse_PublicUserInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:afterline.GetPublicUserInfoResponse.PublicUserInfo) */ {
 public:
  inline GetPublicUserInfoResponse_PublicUserInfo() : GetPublicUserInfoResponse_PublicUserInfo(nullptr) {}
  ~GetPublicUserInfoResponse_PublicUserInfo() override;
  explicit constexpr GetPublicUserInfoResponse_PublicUserInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetPublicUserInfoResponse_PublicUserInfo(const GetPublicUserInfoResponse_PublicUserInfo& from);
  GetPublicUserInfoResponse_PublicUserInfo(GetPublicUserInfoResponse_PublicUserInfo&& from) noexcept
    : GetPublicUserInfoResponse_PublicUserInfo() {
    *this = ::std::move(from);
  }

  inline GetPublicUserInfoResponse_PublicUserInfo& operator=(const GetPublicUserInfoResponse_PublicUserInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetPublicUserInfoResponse_PublicUserInfo& operator=(GetPublicUserInfoResponse_PublicUserInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetPublicUserInfoResponse_PublicUserInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetPublicUserInfoResponse_PublicUserInfo* internal_default_instance() {
    return reinterpret_cast<const GetPublicUserInfoResponse_PublicUserInfo*>(
               &_GetPublicUserInfoResponse_PublicUserInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(GetPublicUserInfoResponse_PublicUserInfo& a, GetPublicUserInfoResponse_PublicUserInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(GetPublicUserInfoResponse_PublicUserInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetPublicUserInfoResponse_PublicUserInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetPublicUserInfoResponse_PublicUserInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetPublicUserInfoResponse_PublicUserInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetPublicUserInfoResponse_PublicUserInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetPublicUserInfoResponse_PublicUserInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetPublicUserInfoResponse_PublicUserInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "afterline.GetPublicUserInfoResponse.PublicUserInfo";
  }
  protected:
  explicit GetPublicUserInfoResponse_PublicUserInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef GetPublicUserInfoResponse_PublicUserInfo_Status Status;
  static constexpr Status OFFLINE =
    GetPublicUserInfoResponse_PublicUserInfo_Status_OFFLINE;
  static constexpr Status ONLINE =
    GetPublicUserInfoResponse_PublicUserInfo_Status_ONLINE;
  static constexpr Status IN_GAME =
    GetPublicUserInfoResponse_PublicUserInfo_Status_IN_GAME;
  static inline bool Status_IsValid(int value) {
    return GetPublicUserInfoResponse_PublicUserInfo_Status_IsValid(value);
  }
  static constexpr Status Status_MIN =
    GetPublicUserInfoResponse_PublicUserInfo_Status_Status_MIN;
  static constexpr Status Status_MAX =
    GetPublicUserInfoResponse_PublicUserInfo_Status_Status_MAX;
  static constexpr int Status_ARRAYSIZE =
    GetPublicUserInfoResponse_PublicUserInfo_Status_Status_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Status_descriptor() {
    return GetPublicUserInfoResponse_PublicUserInfo_Status_descriptor();
  }
  template<typename T>
  static inline const std::string& Status_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Status>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Status_Name.");
    return GetPublicUserInfoResponse_PublicUserInfo_Status_Name(enum_t_value);
  }
  static inline bool Status_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Status* value) {
    return GetPublicUserInfoResponse_PublicUserInfo_Status_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kPublicGamesJoinedFieldNumber = 7,
    kFriendsFieldNumber = 8,
    kUsernameFieldNumber = 1,
    kDisplayNameFieldNumber = 2,
    kUserDescFieldNumber = 3,
    kUserStatusMsgFieldNumber = 4,
    kIconSetFieldNumber = 6,
    kStatusFieldNumber = 5,
  };
  // repeated fixed64 public_games_joined = 7;
  int public_games_joined_size() const;
  private:
  int _internal_public_games_joined_size() const;
  public:
  void clear_public_games_joined();
  private:
  uint64_t _internal_public_games_joined(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _internal_public_games_joined() const;
  void _internal_add_public_games_joined(uint64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      _internal_mutable_public_games_joined();
  public:
  uint64_t public_games_joined(int index) const;
  void set_public_games_joined(int index, uint64_t value);
  void add_public_games_joined(uint64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      public_games_joined() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      mutable_public_games_joined();

  // repeated fixed64 friends = 8;
  int friends_size() const;
  private:
  int _internal_friends_size() const;
  public:
  void clear_friends();
  private:
  uint64_t _internal_friends(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _internal_friends() const;
  void _internal_add_friends(uint64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      _internal_mutable_friends();
  public:
  uint64_t friends(int index) const;
  void set_friends(int index, uint64_t value);
  void add_friends(uint64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      friends() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      mutable_friends();

  // string username = 1;
  void clear_username();
  const std::string& username() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_username(ArgT0&& arg0, ArgT... args);
  std::string* mutable_username();
  PROTOBUF_NODISCARD std::string* release_username();
  void set_allocated_username(std::string* username);
  private:
  const std::string& _internal_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_username(const std::string& value);
  std::string* _internal_mutable_username();
  public:

  // optional string display_name = 2;
  bool has_display_name() const;
  private:
  bool _internal_has_display_name() const;
  public:
  void clear_display_name();
  const std::string& display_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_display_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_display_name();
  PROTOBUF_NODISCARD std::string* release_display_name();
  void set_allocated_display_name(std::string* display_name);
  private:
  const std::string& _internal_display_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_display_name(const std::string& value);
  std::string* _internal_mutable_display_name();
  public:

  // optional string user_desc = 3;
  bool has_user_desc() const;
  private:
  bool _internal_has_user_desc() const;
  public:
  void clear_user_desc();
  const std::string& user_desc() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_desc(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_desc();
  PROTOBUF_NODISCARD std::string* release_user_desc();
  void set_allocated_user_desc(std::string* user_desc);
  private:
  const std::string& _internal_user_desc() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_desc(const std::string& value);
  std::string* _internal_mutable_user_desc();
  public:

  // optional string user_status_msg = 4;
  bool has_user_status_msg() const;
  private:
  bool _internal_has_user_status_msg() const;
  public:
  void clear_user_status_msg();
  const std::string& user_status_msg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_status_msg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_status_msg();
  PROTOBUF_NODISCARD std::string* release_user_status_msg();
  void set_allocated_user_status_msg(std::string* user_status_msg);
  private:
  const std::string& _internal_user_status_msg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_status_msg(const std::string& value);
  std::string* _internal_mutable_user_status_msg();
  public:

  // optional .afterline.IconSetInfo icon_set = 6;
  bool has_icon_set() const;
  private:
  bool _internal_has_icon_set() const;
  public:
  void clear_icon_set();
  const ::afterline::IconSetInfo& icon_set() const;
  PROTOBUF_NODISCARD ::afterline::IconSetInfo* release_icon_set();
  ::afterline::IconSetInfo* mutable_icon_set();
  void set_allocated_icon_set(::afterline::IconSetInfo* icon_set);
  private:
  const ::afterline::IconSetInfo& _internal_icon_set() const;
  ::afterline::IconSetInfo* _internal_mutable_icon_set();
  public:
  void unsafe_arena_set_allocated_icon_set(
      ::afterline::IconSetInfo* icon_set);
  ::afterline::IconSetInfo* unsafe_arena_release_icon_set();

  // .afterline.GetPublicUserInfoResponse.PublicUserInfo.Status status = 5;
  void clear_status();
  ::afterline::GetPublicUserInfoResponse_PublicUserInfo_Status status() const;
  void set_status(::afterline::GetPublicUserInfoResponse_PublicUserInfo_Status value);
  private:
  ::afterline::GetPublicUserInfoResponse_PublicUserInfo_Status _internal_status() const;
  void _internal_set_status(::afterline::GetPublicUserInfoResponse_PublicUserInfo_Status value);
  public:

  // @@protoc_insertion_point(class_scope:afterline.GetPublicUserInfoResponse.PublicUserInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t > public_games_joined_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t > friends_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr display_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_desc_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_status_msg_;
  ::afterline::IconSetInfo* icon_set_;
  int status_;
  friend struct ::TableStruct_afterline_2fsystem_2eproto;
};
// -------------------------------------------------------------------

class GetPublicUserInfoResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:afterline.GetPublicUserInfoResponse) */ {
 public:
  inline GetPublicUserInfoResponse() : GetPublicUserInfoResponse(nullptr) {}
  ~GetPublicUserInfoResponse() override;
  explicit constexpr GetPublicUserInfoResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetPublicUserInfoResponse(const GetPublicUserInfoResponse& from);
  GetPublicUserInfoResponse(GetPublicUserInfoResponse&& from) noexcept
    : GetPublicUserInfoResponse() {
    *this = ::std::move(from);
  }

  inline GetPublicUserInfoResponse& operator=(const GetPublicUserInfoResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetPublicUserInfoResponse& operator=(GetPublicUserInfoResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetPublicUserInfoResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetPublicUserInfoResponse* internal_default_instance() {
    return reinterpret_cast<const GetPublicUserInfoResponse*>(
               &_GetPublicUserInfoResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(GetPublicUserInfoResponse& a, GetPublicUserInfoResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetPublicUserInfoResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetPublicUserInfoResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetPublicUserInfoResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetPublicUserInfoResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetPublicUserInfoResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetPublicUserInfoResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetPublicUserInfoResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "afterline.GetPublicUserInfoResponse";
  }
  protected:
  explicit GetPublicUserInfoResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef GetPublicUserInfoResponse_PublicUserInfo PublicUserInfo;

  // accessors -------------------------------------------------------

  enum : int {
    kUserInfoFieldNumber = 2,
    kUserIdFieldNumber = 1,
  };
  // optional .afterline.GetPublicUserInfoResponse.PublicUserInfo user_info = 2;
  bool has_user_info() const;
  private:
  bool _internal_has_user_info() const;
  public:
  void clear_user_info();
  const ::afterline::GetPublicUserInfoResponse_PublicUserInfo& user_info() const;
  PROTOBUF_NODISCARD ::afterline::GetPublicUserInfoResponse_PublicUserInfo* release_user_info();
  ::afterline::GetPublicUserInfoResponse_PublicUserInfo* mutable_user_info();
  void set_allocated_user_info(::afterline::GetPublicUserInfoResponse_PublicUserInfo* user_info);
  private:
  const ::afterline::GetPublicUserInfoResponse_PublicUserInfo& _internal_user_info() const;
  ::afterline::GetPublicUserInfoResponse_PublicUserInfo* _internal_mutable_user_info();
  public:
  void unsafe_arena_set_allocated_user_info(
      ::afterline::GetPublicUserInfoResponse_PublicUserInfo* user_info);
  ::afterline::GetPublicUserInfoResponse_PublicUserInfo* unsafe_arena_release_user_info();

  // fixed64 user_id = 1;
  void clear_user_id();
  uint64_t user_id() const;
  void set_user_id(uint64_t value);
  private:
  uint64_t _internal_user_id() const;
  void _internal_set_user_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:afterline.GetPublicUserInfoResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::afterline::GetPublicUserInfoResponse_PublicUserInfo* user_info_;
  uint64_t user_id_;
  friend struct ::TableStruct_afterline_2fsystem_2eproto;
};
// -------------------------------------------------------------------

class GetUserIDRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:afterline.GetUserIDRequest) */ {
 public:
  inline GetUserIDRequest() : GetUserIDRequest(nullptr) {}
  ~GetUserIDRequest() override;
  explicit constexpr GetUserIDRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetUserIDRequest(const GetUserIDRequest& from);
  GetUserIDRequest(GetUserIDRequest&& from) noexcept
    : GetUserIDRequest() {
    *this = ::std::move(from);
  }

  inline GetUserIDRequest& operator=(const GetUserIDRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetUserIDRequest& operator=(GetUserIDRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetUserIDRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetUserIDRequest* internal_default_instance() {
    return reinterpret_cast<const GetUserIDRequest*>(
               &_GetUserIDRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(GetUserIDRequest& a, GetUserIDRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetUserIDRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetUserIDRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetUserIDRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetUserIDRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetUserIDRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetUserIDRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetUserIDRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "afterline.GetUserIDRequest";
  }
  protected:
  explicit GetUserIDRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSessionIdFieldNumber = 1,
  };
  // fixed64 session_id = 1;
  void clear_session_id();
  uint64_t session_id() const;
  void set_session_id(uint64_t value);
  private:
  uint64_t _internal_session_id() const;
  void _internal_set_session_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:afterline.GetUserIDRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint64_t session_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_afterline_2fsystem_2eproto;
};
// -------------------------------------------------------------------

class GetUserIDResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:afterline.GetUserIDResponse) */ {
 public:
  inline GetUserIDResponse() : GetUserIDResponse(nullptr) {}
  ~GetUserIDResponse() override;
  explicit constexpr GetUserIDResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetUserIDResponse(const GetUserIDResponse& from);
  GetUserIDResponse(GetUserIDResponse&& from) noexcept
    : GetUserIDResponse() {
    *this = ::std::move(from);
  }

  inline GetUserIDResponse& operator=(const GetUserIDResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetUserIDResponse& operator=(GetUserIDResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetUserIDResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetUserIDResponse* internal_default_instance() {
    return reinterpret_cast<const GetUserIDResponse*>(
               &_GetUserIDResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(GetUserIDResponse& a, GetUserIDResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetUserIDResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetUserIDResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetUserIDResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetUserIDResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetUserIDResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetUserIDResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetUserIDResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "afterline.GetUserIDResponse";
  }
  protected:
  explicit GetUserIDResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIdFieldNumber = 1,
  };
  // fixed64 user_id = 1;
  void clear_user_id();
  uint64_t user_id() const;
  void set_user_id(uint64_t value);
  private:
  uint64_t _internal_user_id() const;
  void _internal_set_user_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:afterline.GetUserIDResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint64_t user_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_afterline_2fsystem_2eproto;
};
// -------------------------------------------------------------------

class FindUserRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:afterline.FindUserRequest) */ {
 public:
  inline FindUserRequest() : FindUserRequest(nullptr) {}
  ~FindUserRequest() override;
  explicit constexpr FindUserRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FindUserRequest(const FindUserRequest& from);
  FindUserRequest(FindUserRequest&& from) noexcept
    : FindUserRequest() {
    *this = ::std::move(from);
  }

  inline FindUserRequest& operator=(const FindUserRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline FindUserRequest& operator=(FindUserRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FindUserRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const FindUserRequest* internal_default_instance() {
    return reinterpret_cast<const FindUserRequest*>(
               &_FindUserRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(FindUserRequest& a, FindUserRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(FindUserRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FindUserRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FindUserRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FindUserRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FindUserRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const FindUserRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FindUserRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "afterline.FindUserRequest";
  }
  protected:
  explicit FindUserRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSearchTermFieldNumber = 2,
    kSessionIdFieldNumber = 1,
  };
  // string search_term = 2;
  void clear_search_term();
  const std::string& search_term() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_search_term(ArgT0&& arg0, ArgT... args);
  std::string* mutable_search_term();
  PROTOBUF_NODISCARD std::string* release_search_term();
  void set_allocated_search_term(std::string* search_term);
  private:
  const std::string& _internal_search_term() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_search_term(const std::string& value);
  std::string* _internal_mutable_search_term();
  public:

  // fixed64 session_id = 1;
  void clear_session_id();
  uint64_t session_id() const;
  void set_session_id(uint64_t value);
  private:
  uint64_t _internal_session_id() const;
  void _internal_set_session_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:afterline.FindUserRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr search_term_;
  uint64_t session_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_afterline_2fsystem_2eproto;
};
// -------------------------------------------------------------------

class FindUserResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:afterline.FindUserResponse) */ {
 public:
  inline FindUserResponse() : FindUserResponse(nullptr) {}
  ~FindUserResponse() override;
  explicit constexpr FindUserResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FindUserResponse(const FindUserResponse& from);
  FindUserResponse(FindUserResponse&& from) noexcept
    : FindUserResponse() {
    *this = ::std::move(from);
  }

  inline FindUserResponse& operator=(const FindUserResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline FindUserResponse& operator=(FindUserResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FindUserResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const FindUserResponse* internal_default_instance() {
    return reinterpret_cast<const FindUserResponse*>(
               &_FindUserResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(FindUserResponse& a, FindUserResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(FindUserResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FindUserResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FindUserResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FindUserResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FindUserResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const FindUserResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FindUserResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "afterline.FindUserResponse";
  }
  protected:
  explicit FindUserResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUsersFieldNumber = 1,
  };
  // repeated fixed64 users = 1;
  int users_size() const;
  private:
  int _internal_users_size() const;
  public:
  void clear_users();
  private:
  uint64_t _internal_users(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _internal_users() const;
  void _internal_add_users(uint64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      _internal_mutable_users();
  public:
  uint64_t users(int index) const;
  void set_users(int index, uint64_t value);
  void add_users(uint64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      users() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      mutable_users();

  // @@protoc_insertion_point(class_scope:afterline.FindUserResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t > users_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_afterline_2fsystem_2eproto;
};
// -------------------------------------------------------------------

class BlockUserRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:afterline.BlockUserRequest) */ {
 public:
  inline BlockUserRequest() : BlockUserRequest(nullptr) {}
  ~BlockUserRequest() override;
  explicit constexpr BlockUserRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BlockUserRequest(const BlockUserRequest& from);
  BlockUserRequest(BlockUserRequest&& from) noexcept
    : BlockUserRequest() {
    *this = ::std::move(from);
  }

  inline BlockUserRequest& operator=(const BlockUserRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline BlockUserRequest& operator=(BlockUserRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BlockUserRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const BlockUserRequest* internal_default_instance() {
    return reinterpret_cast<const BlockUserRequest*>(
               &_BlockUserRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(BlockUserRequest& a, BlockUserRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(BlockUserRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BlockUserRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BlockUserRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BlockUserRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BlockUserRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const BlockUserRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BlockUserRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "afterline.BlockUserRequest";
  }
  protected:
  explicit BlockUserRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSessionIdFieldNumber = 1,
    kUserIdFieldNumber = 2,
    kBlockFieldNumber = 3,
  };
  // fixed64 session_id = 1;
  void clear_session_id();
  uint64_t session_id() const;
  void set_session_id(uint64_t value);
  private:
  uint64_t _internal_session_id() const;
  void _internal_set_session_id(uint64_t value);
  public:

  // fixed64 user_id = 2;
  void clear_user_id();
  uint64_t user_id() const;
  void set_user_id(uint64_t value);
  private:
  uint64_t _internal_user_id() const;
  void _internal_set_user_id(uint64_t value);
  public:

  // bool block = 3;
  void clear_block();
  bool block() const;
  void set_block(bool value);
  private:
  bool _internal_block() const;
  void _internal_set_block(bool value);
  public:

  // @@protoc_insertion_point(class_scope:afterline.BlockUserRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint64_t session_id_;
  uint64_t user_id_;
  bool block_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_afterline_2fsystem_2eproto;
};
// -------------------------------------------------------------------

class BlockUserResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:afterline.BlockUserResponse) */ {
 public:
  inline BlockUserResponse() : BlockUserResponse(nullptr) {}
  ~BlockUserResponse() override;
  explicit constexpr BlockUserResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BlockUserResponse(const BlockUserResponse& from);
  BlockUserResponse(BlockUserResponse&& from) noexcept
    : BlockUserResponse() {
    *this = ::std::move(from);
  }

  inline BlockUserResponse& operator=(const BlockUserResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline BlockUserResponse& operator=(BlockUserResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BlockUserResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const BlockUserResponse* internal_default_instance() {
    return reinterpret_cast<const BlockUserResponse*>(
               &_BlockUserResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(BlockUserResponse& a, BlockUserResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(BlockUserResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BlockUserResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BlockUserResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BlockUserResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BlockUserResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const BlockUserResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BlockUserResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "afterline.BlockUserResponse";
  }
  protected:
  explicit BlockUserResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSessionIdFieldNumber = 1,
    kUserIdFieldNumber = 2,
    kSuccessfulFieldNumber = 3,
  };
  // fixed64 session_id = 1;
  void clear_session_id();
  uint64_t session_id() const;
  void set_session_id(uint64_t value);
  private:
  uint64_t _internal_session_id() const;
  void _internal_set_session_id(uint64_t value);
  public:

  // fixed64 user_id = 2;
  void clear_user_id();
  uint64_t user_id() const;
  void set_user_id(uint64_t value);
  private:
  uint64_t _internal_user_id() const;
  void _internal_set_user_id(uint64_t value);
  public:

  // bool successful = 3;
  void clear_successful();
  bool successful() const;
  void set_successful(bool value);
  private:
  bool _internal_successful() const;
  void _internal_set_successful(bool value);
  public:

  // @@protoc_insertion_point(class_scope:afterline.BlockUserResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint64_t session_id_;
  uint64_t user_id_;
  bool successful_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_afterline_2fsystem_2eproto;
};
// -------------------------------------------------------------------

class FriendUserRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:afterline.FriendUserRequest) */ {
 public:
  inline FriendUserRequest() : FriendUserRequest(nullptr) {}
  ~FriendUserRequest() override;
  explicit constexpr FriendUserRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FriendUserRequest(const FriendUserRequest& from);
  FriendUserRequest(FriendUserRequest&& from) noexcept
    : FriendUserRequest() {
    *this = ::std::move(from);
  }

  inline FriendUserRequest& operator=(const FriendUserRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline FriendUserRequest& operator=(FriendUserRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FriendUserRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const FriendUserRequest* internal_default_instance() {
    return reinterpret_cast<const FriendUserRequest*>(
               &_FriendUserRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(FriendUserRequest& a, FriendUserRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(FriendUserRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FriendUserRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FriendUserRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FriendUserRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FriendUserRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const FriendUserRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FriendUserRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "afterline.FriendUserRequest";
  }
  protected:
  explicit FriendUserRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSessionIdFieldNumber = 1,
    kUserIdFieldNumber = 2,
  };
  // fixed64 session_id = 1;
  void clear_session_id();
  uint64_t session_id() const;
  void set_session_id(uint64_t value);
  private:
  uint64_t _internal_session_id() const;
  void _internal_set_session_id(uint64_t value);
  public:

  // fixed64 user_id = 2;
  void clear_user_id();
  uint64_t user_id() const;
  void set_user_id(uint64_t value);
  private:
  uint64_t _internal_user_id() const;
  void _internal_set_user_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:afterline.FriendUserRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint64_t session_id_;
  uint64_t user_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_afterline_2fsystem_2eproto;
};
// -------------------------------------------------------------------

class FriendUserResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:afterline.FriendUserResponse) */ {
 public:
  inline FriendUserResponse() : FriendUserResponse(nullptr) {}
  ~FriendUserResponse() override;
  explicit constexpr FriendUserResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FriendUserResponse(const FriendUserResponse& from);
  FriendUserResponse(FriendUserResponse&& from) noexcept
    : FriendUserResponse() {
    *this = ::std::move(from);
  }

  inline FriendUserResponse& operator=(const FriendUserResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline FriendUserResponse& operator=(FriendUserResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FriendUserResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const FriendUserResponse* internal_default_instance() {
    return reinterpret_cast<const FriendUserResponse*>(
               &_FriendUserResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(FriendUserResponse& a, FriendUserResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(FriendUserResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FriendUserResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FriendUserResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FriendUserResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FriendUserResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const FriendUserResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FriendUserResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "afterline.FriendUserResponse";
  }
  protected:
  explicit FriendUserResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef FriendUserResponse_Status Status;
  static constexpr Status PENDING =
    FriendUserResponse_Status_PENDING;
  static constexpr Status BLOCKED =
    FriendUserResponse_Status_BLOCKED;
  static constexpr Status ACCEPTED =
    FriendUserResponse_Status_ACCEPTED;
  static inline bool Status_IsValid(int value) {
    return FriendUserResponse_Status_IsValid(value);
  }
  static constexpr Status Status_MIN =
    FriendUserResponse_Status_Status_MIN;
  static constexpr Status Status_MAX =
    FriendUserResponse_Status_Status_MAX;
  static constexpr int Status_ARRAYSIZE =
    FriendUserResponse_Status_Status_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Status_descriptor() {
    return FriendUserResponse_Status_descriptor();
  }
  template<typename T>
  static inline const std::string& Status_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Status>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Status_Name.");
    return FriendUserResponse_Status_Name(enum_t_value);
  }
  static inline bool Status_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Status* value) {
    return FriendUserResponse_Status_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kSessionIdFieldNumber = 1,
    kUserIdFieldNumber = 2,
  };
  // fixed64 session_id = 1;
  void clear_session_id();
  uint64_t session_id() const;
  void set_session_id(uint64_t value);
  private:
  uint64_t _internal_session_id() const;
  void _internal_set_session_id(uint64_t value);
  public:

  // fixed64 user_id = 2;
  void clear_user_id();
  uint64_t user_id() const;
  void set_user_id(uint64_t value);
  private:
  uint64_t _internal_user_id() const;
  void _internal_set_user_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:afterline.FriendUserResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint64_t session_id_;
  uint64_t user_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_afterline_2fsystem_2eproto;
};
// -------------------------------------------------------------------

class UnFriendUserRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:afterline.UnFriendUserRequest) */ {
 public:
  inline UnFriendUserRequest() : UnFriendUserRequest(nullptr) {}
  ~UnFriendUserRequest() override;
  explicit constexpr UnFriendUserRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UnFriendUserRequest(const UnFriendUserRequest& from);
  UnFriendUserRequest(UnFriendUserRequest&& from) noexcept
    : UnFriendUserRequest() {
    *this = ::std::move(from);
  }

  inline UnFriendUserRequest& operator=(const UnFriendUserRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UnFriendUserRequest& operator=(UnFriendUserRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UnFriendUserRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UnFriendUserRequest* internal_default_instance() {
    return reinterpret_cast<const UnFriendUserRequest*>(
               &_UnFriendUserRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(UnFriendUserRequest& a, UnFriendUserRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UnFriendUserRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UnFriendUserRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UnFriendUserRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UnFriendUserRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UnFriendUserRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UnFriendUserRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UnFriendUserRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "afterline.UnFriendUserRequest";
  }
  protected:
  explicit UnFriendUserRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSessionIdFieldNumber = 1,
    kUserIdFieldNumber = 2,
  };
  // fixed64 session_id = 1;
  void clear_session_id();
  uint64_t session_id() const;
  void set_session_id(uint64_t value);
  private:
  uint64_t _internal_session_id() const;
  void _internal_set_session_id(uint64_t value);
  public:

  // fixed64 user_id = 2;
  void clear_user_id();
  uint64_t user_id() const;
  void set_user_id(uint64_t value);
  private:
  uint64_t _internal_user_id() const;
  void _internal_set_user_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:afterline.UnFriendUserRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint64_t session_id_;
  uint64_t user_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_afterline_2fsystem_2eproto;
};
// -------------------------------------------------------------------

class UnFriendUserResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:afterline.UnFriendUserResponse) */ {
 public:
  inline UnFriendUserResponse() : UnFriendUserResponse(nullptr) {}
  ~UnFriendUserResponse() override;
  explicit constexpr UnFriendUserResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UnFriendUserResponse(const UnFriendUserResponse& from);
  UnFriendUserResponse(UnFriendUserResponse&& from) noexcept
    : UnFriendUserResponse() {
    *this = ::std::move(from);
  }

  inline UnFriendUserResponse& operator=(const UnFriendUserResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline UnFriendUserResponse& operator=(UnFriendUserResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UnFriendUserResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const UnFriendUserResponse* internal_default_instance() {
    return reinterpret_cast<const UnFriendUserResponse*>(
               &_UnFriendUserResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(UnFriendUserResponse& a, UnFriendUserResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(UnFriendUserResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UnFriendUserResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UnFriendUserResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UnFriendUserResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UnFriendUserResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UnFriendUserResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UnFriendUserResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "afterline.UnFriendUserResponse";
  }
  protected:
  explicit UnFriendUserResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIdFieldNumber = 1,
    kSuccessfulFieldNumber = 2,
  };
  // fixed64 user_id = 1;
  void clear_user_id();
  uint64_t user_id() const;
  void set_user_id(uint64_t value);
  private:
  uint64_t _internal_user_id() const;
  void _internal_set_user_id(uint64_t value);
  public:

  // bool successful = 2;
  void clear_successful();
  bool successful() const;
  void set_successful(bool value);
  private:
  bool _internal_successful() const;
  void _internal_set_successful(bool value);
  public:

  // @@protoc_insertion_point(class_scope:afterline.UnFriendUserResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint64_t user_id_;
  bool successful_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_afterline_2fsystem_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// FederatedLoginRequest

// bool remember_me = 1;
inline void FederatedLoginRequest::clear_remember_me() {
  remember_me_ = false;
}
inline bool FederatedLoginRequest::_internal_remember_me() const {
  return remember_me_;
}
inline bool FederatedLoginRequest::remember_me() const {
  // @@protoc_insertion_point(field_get:afterline.FederatedLoginRequest.remember_me)
  return _internal_remember_me();
}
inline void FederatedLoginRequest::_internal_set_remember_me(bool value) {
  
  remember_me_ = value;
}
inline void FederatedLoginRequest::set_remember_me(bool value) {
  _internal_set_remember_me(value);
  // @@protoc_insertion_point(field_set:afterline.FederatedLoginRequest.remember_me)
}

// -------------------------------------------------------------------

// FederatedLoginResponse

// string link = 1;
inline void FederatedLoginResponse::clear_link() {
  link_.ClearToEmpty();
}
inline const std::string& FederatedLoginResponse::link() const {
  // @@protoc_insertion_point(field_get:afterline.FederatedLoginResponse.link)
  return _internal_link();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FederatedLoginResponse::set_link(ArgT0&& arg0, ArgT... args) {
 
 link_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:afterline.FederatedLoginResponse.link)
}
inline std::string* FederatedLoginResponse::mutable_link() {
  std::string* _s = _internal_mutable_link();
  // @@protoc_insertion_point(field_mutable:afterline.FederatedLoginResponse.link)
  return _s;
}
inline const std::string& FederatedLoginResponse::_internal_link() const {
  return link_.Get();
}
inline void FederatedLoginResponse::_internal_set_link(const std::string& value) {
  
  link_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* FederatedLoginResponse::_internal_mutable_link() {
  
  return link_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* FederatedLoginResponse::release_link() {
  // @@protoc_insertion_point(field_release:afterline.FederatedLoginResponse.link)
  return link_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void FederatedLoginResponse::set_allocated_link(std::string* link) {
  if (link != nullptr) {
    
  } else {
    
  }
  link_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), link,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (link_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    link_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:afterline.FederatedLoginResponse.link)
}

// -------------------------------------------------------------------

// FederatedLoginComplete

// fixed64 client_session_id = 1;
inline void FederatedLoginComplete::clear_client_session_id() {
  client_session_id_ = uint64_t{0u};
}
inline uint64_t FederatedLoginComplete::_internal_client_session_id() const {
  return client_session_id_;
}
inline uint64_t FederatedLoginComplete::client_session_id() const {
  // @@protoc_insertion_point(field_get:afterline.FederatedLoginComplete.client_session_id)
  return _internal_client_session_id();
}
inline void FederatedLoginComplete::_internal_set_client_session_id(uint64_t value) {
  
  client_session_id_ = value;
}
inline void FederatedLoginComplete::set_client_session_id(uint64_t value) {
  _internal_set_client_session_id(value);
  // @@protoc_insertion_point(field_set:afterline.FederatedLoginComplete.client_session_id)
}

// string user_email = 2;
inline void FederatedLoginComplete::clear_user_email() {
  user_email_.ClearToEmpty();
}
inline const std::string& FederatedLoginComplete::user_email() const {
  // @@protoc_insertion_point(field_get:afterline.FederatedLoginComplete.user_email)
  return _internal_user_email();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FederatedLoginComplete::set_user_email(ArgT0&& arg0, ArgT... args) {
 
 user_email_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:afterline.FederatedLoginComplete.user_email)
}
inline std::string* FederatedLoginComplete::mutable_user_email() {
  std::string* _s = _internal_mutable_user_email();
  // @@protoc_insertion_point(field_mutable:afterline.FederatedLoginComplete.user_email)
  return _s;
}
inline const std::string& FederatedLoginComplete::_internal_user_email() const {
  return user_email_.Get();
}
inline void FederatedLoginComplete::_internal_set_user_email(const std::string& value) {
  
  user_email_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* FederatedLoginComplete::_internal_mutable_user_email() {
  
  return user_email_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* FederatedLoginComplete::release_user_email() {
  // @@protoc_insertion_point(field_release:afterline.FederatedLoginComplete.user_email)
  return user_email_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void FederatedLoginComplete::set_allocated_user_email(std::string* user_email) {
  if (user_email != nullptr) {
    
  } else {
    
  }
  user_email_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), user_email,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (user_email_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    user_email_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:afterline.FederatedLoginComplete.user_email)
}

// string user_name = 3;
inline void FederatedLoginComplete::clear_user_name() {
  user_name_.ClearToEmpty();
}
inline const std::string& FederatedLoginComplete::user_name() const {
  // @@protoc_insertion_point(field_get:afterline.FederatedLoginComplete.user_name)
  return _internal_user_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FederatedLoginComplete::set_user_name(ArgT0&& arg0, ArgT... args) {
 
 user_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:afterline.FederatedLoginComplete.user_name)
}
inline std::string* FederatedLoginComplete::mutable_user_name() {
  std::string* _s = _internal_mutable_user_name();
  // @@protoc_insertion_point(field_mutable:afterline.FederatedLoginComplete.user_name)
  return _s;
}
inline const std::string& FederatedLoginComplete::_internal_user_name() const {
  return user_name_.Get();
}
inline void FederatedLoginComplete::_internal_set_user_name(const std::string& value) {
  
  user_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* FederatedLoginComplete::_internal_mutable_user_name() {
  
  return user_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* FederatedLoginComplete::release_user_name() {
  // @@protoc_insertion_point(field_release:afterline.FederatedLoginComplete.user_name)
  return user_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void FederatedLoginComplete::set_allocated_user_name(std::string* user_name) {
  if (user_name != nullptr) {
    
  } else {
    
  }
  user_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), user_name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (user_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    user_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:afterline.FederatedLoginComplete.user_name)
}

// -------------------------------------------------------------------

// FederatedLoginTimeout

// -------------------------------------------------------------------

// CancelFederatedLogin

// -------------------------------------------------------------------

// FederatedLogOutRequest

// fixed64 client_session_id = 1;
inline void FederatedLogOutRequest::clear_client_session_id() {
  client_session_id_ = uint64_t{0u};
}
inline uint64_t FederatedLogOutRequest::_internal_client_session_id() const {
  return client_session_id_;
}
inline uint64_t FederatedLogOutRequest::client_session_id() const {
  // @@protoc_insertion_point(field_get:afterline.FederatedLogOutRequest.client_session_id)
  return _internal_client_session_id();
}
inline void FederatedLogOutRequest::_internal_set_client_session_id(uint64_t value) {
  
  client_session_id_ = value;
}
inline void FederatedLogOutRequest::set_client_session_id(uint64_t value) {
  _internal_set_client_session_id(value);
  // @@protoc_insertion_point(field_set:afterline.FederatedLogOutRequest.client_session_id)
}

// -------------------------------------------------------------------

// FederatedLogOutResponse

// bool succeeded = 1;
inline void FederatedLogOutResponse::clear_succeeded() {
  succeeded_ = false;
}
inline bool FederatedLogOutResponse::_internal_succeeded() const {
  return succeeded_;
}
inline bool FederatedLogOutResponse::succeeded() const {
  // @@protoc_insertion_point(field_get:afterline.FederatedLogOutResponse.succeeded)
  return _internal_succeeded();
}
inline void FederatedLogOutResponse::_internal_set_succeeded(bool value) {
  
  succeeded_ = value;
}
inline void FederatedLogOutResponse::set_succeeded(bool value) {
  _internal_set_succeeded(value);
  // @@protoc_insertion_point(field_set:afterline.FederatedLogOutResponse.succeeded)
}

// -------------------------------------------------------------------

// ValidateSessionIdRequest

// fixed64 client_session_id = 1;
inline void ValidateSessionIdRequest::clear_client_session_id() {
  client_session_id_ = uint64_t{0u};
}
inline uint64_t ValidateSessionIdRequest::_internal_client_session_id() const {
  return client_session_id_;
}
inline uint64_t ValidateSessionIdRequest::client_session_id() const {
  // @@protoc_insertion_point(field_get:afterline.ValidateSessionIdRequest.client_session_id)
  return _internal_client_session_id();
}
inline void ValidateSessionIdRequest::_internal_set_client_session_id(uint64_t value) {
  
  client_session_id_ = value;
}
inline void ValidateSessionIdRequest::set_client_session_id(uint64_t value) {
  _internal_set_client_session_id(value);
  // @@protoc_insertion_point(field_set:afterline.ValidateSessionIdRequest.client_session_id)
}

// -------------------------------------------------------------------

// ValidateSessionIdResponse

// bool valid = 1;
inline void ValidateSessionIdResponse::clear_valid() {
  valid_ = false;
}
inline bool ValidateSessionIdResponse::_internal_valid() const {
  return valid_;
}
inline bool ValidateSessionIdResponse::valid() const {
  // @@protoc_insertion_point(field_get:afterline.ValidateSessionIdResponse.valid)
  return _internal_valid();
}
inline void ValidateSessionIdResponse::_internal_set_valid(bool value) {
  
  valid_ = value;
}
inline void ValidateSessionIdResponse::set_valid(bool value) {
  _internal_set_valid(value);
  // @@protoc_insertion_point(field_set:afterline.ValidateSessionIdResponse.valid)
}

// -------------------------------------------------------------------

// Disconnect

// fixed64 session_id = 1;
inline void Disconnect::clear_session_id() {
  session_id_ = uint64_t{0u};
}
inline uint64_t Disconnect::_internal_session_id() const {
  return session_id_;
}
inline uint64_t Disconnect::session_id() const {
  // @@protoc_insertion_point(field_get:afterline.Disconnect.session_id)
  return _internal_session_id();
}
inline void Disconnect::_internal_set_session_id(uint64_t value) {
  
  session_id_ = value;
}
inline void Disconnect::set_session_id(uint64_t value) {
  _internal_set_session_id(value);
  // @@protoc_insertion_point(field_set:afterline.Disconnect.session_id)
}

// -------------------------------------------------------------------

// Connect

// optional fixed64 session_id = 1;
inline bool Connect::_internal_has_session_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Connect::has_session_id() const {
  return _internal_has_session_id();
}
inline void Connect::clear_session_id() {
  session_id_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000001u;
}
inline uint64_t Connect::_internal_session_id() const {
  return session_id_;
}
inline uint64_t Connect::session_id() const {
  // @@protoc_insertion_point(field_get:afterline.Connect.session_id)
  return _internal_session_id();
}
inline void Connect::_internal_set_session_id(uint64_t value) {
  _has_bits_[0] |= 0x00000001u;
  session_id_ = value;
}
inline void Connect::set_session_id(uint64_t value) {
  _internal_set_session_id(value);
  // @@protoc_insertion_point(field_set:afterline.Connect.session_id)
}

// -------------------------------------------------------------------

// GetUserStatusRequest

// fixed64 session_id = 1;
inline void GetUserStatusRequest::clear_session_id() {
  session_id_ = uint64_t{0u};
}
inline uint64_t GetUserStatusRequest::_internal_session_id() const {
  return session_id_;
}
inline uint64_t GetUserStatusRequest::session_id() const {
  // @@protoc_insertion_point(field_get:afterline.GetUserStatusRequest.session_id)
  return _internal_session_id();
}
inline void GetUserStatusRequest::_internal_set_session_id(uint64_t value) {
  
  session_id_ = value;
}
inline void GetUserStatusRequest::set_session_id(uint64_t value) {
  _internal_set_session_id(value);
  // @@protoc_insertion_point(field_set:afterline.GetUserStatusRequest.session_id)
}

// fixed64 user_id = 2;
inline void GetUserStatusRequest::clear_user_id() {
  user_id_ = uint64_t{0u};
}
inline uint64_t GetUserStatusRequest::_internal_user_id() const {
  return user_id_;
}
inline uint64_t GetUserStatusRequest::user_id() const {
  // @@protoc_insertion_point(field_get:afterline.GetUserStatusRequest.user_id)
  return _internal_user_id();
}
inline void GetUserStatusRequest::_internal_set_user_id(uint64_t value) {
  
  user_id_ = value;
}
inline void GetUserStatusRequest::set_user_id(uint64_t value) {
  _internal_set_user_id(value);
  // @@protoc_insertion_point(field_set:afterline.GetUserStatusRequest.user_id)
}

// bool available = 3;
inline void GetUserStatusRequest::clear_available() {
  available_ = false;
}
inline bool GetUserStatusRequest::_internal_available() const {
  return available_;
}
inline bool GetUserStatusRequest::available() const {
  // @@protoc_insertion_point(field_get:afterline.GetUserStatusRequest.available)
  return _internal_available();
}
inline void GetUserStatusRequest::_internal_set_available(bool value) {
  
  available_ = value;
}
inline void GetUserStatusRequest::set_available(bool value) {
  _internal_set_available(value);
  // @@protoc_insertion_point(field_set:afterline.GetUserStatusRequest.available)
}

// -------------------------------------------------------------------

// GetPublicUserInfoRequest

// fixed64 session_id = 1;
inline void GetPublicUserInfoRequest::clear_session_id() {
  session_id_ = uint64_t{0u};
}
inline uint64_t GetPublicUserInfoRequest::_internal_session_id() const {
  return session_id_;
}
inline uint64_t GetPublicUserInfoRequest::session_id() const {
  // @@protoc_insertion_point(field_get:afterline.GetPublicUserInfoRequest.session_id)
  return _internal_session_id();
}
inline void GetPublicUserInfoRequest::_internal_set_session_id(uint64_t value) {
  
  session_id_ = value;
}
inline void GetPublicUserInfoRequest::set_session_id(uint64_t value) {
  _internal_set_session_id(value);
  // @@protoc_insertion_point(field_set:afterline.GetPublicUserInfoRequest.session_id)
}

// fixed64 user_id = 2;
inline void GetPublicUserInfoRequest::clear_user_id() {
  user_id_ = uint64_t{0u};
}
inline uint64_t GetPublicUserInfoRequest::_internal_user_id() const {
  return user_id_;
}
inline uint64_t GetPublicUserInfoRequest::user_id() const {
  // @@protoc_insertion_point(field_get:afterline.GetPublicUserInfoRequest.user_id)
  return _internal_user_id();
}
inline void GetPublicUserInfoRequest::_internal_set_user_id(uint64_t value) {
  
  user_id_ = value;
}
inline void GetPublicUserInfoRequest::set_user_id(uint64_t value) {
  _internal_set_user_id(value);
  // @@protoc_insertion_point(field_set:afterline.GetPublicUserInfoRequest.user_id)
}

// -------------------------------------------------------------------

// GetPublicUserInfoResponse_PublicUserInfo

// string username = 1;
inline void GetPublicUserInfoResponse_PublicUserInfo::clear_username() {
  username_.ClearToEmpty();
}
inline const std::string& GetPublicUserInfoResponse_PublicUserInfo::username() const {
  // @@protoc_insertion_point(field_get:afterline.GetPublicUserInfoResponse.PublicUserInfo.username)
  return _internal_username();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetPublicUserInfoResponse_PublicUserInfo::set_username(ArgT0&& arg0, ArgT... args) {
 
 username_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:afterline.GetPublicUserInfoResponse.PublicUserInfo.username)
}
inline std::string* GetPublicUserInfoResponse_PublicUserInfo::mutable_username() {
  std::string* _s = _internal_mutable_username();
  // @@protoc_insertion_point(field_mutable:afterline.GetPublicUserInfoResponse.PublicUserInfo.username)
  return _s;
}
inline const std::string& GetPublicUserInfoResponse_PublicUserInfo::_internal_username() const {
  return username_.Get();
}
inline void GetPublicUserInfoResponse_PublicUserInfo::_internal_set_username(const std::string& value) {
  
  username_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetPublicUserInfoResponse_PublicUserInfo::_internal_mutable_username() {
  
  return username_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetPublicUserInfoResponse_PublicUserInfo::release_username() {
  // @@protoc_insertion_point(field_release:afterline.GetPublicUserInfoResponse.PublicUserInfo.username)
  return username_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetPublicUserInfoResponse_PublicUserInfo::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    
  } else {
    
  }
  username_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), username,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (username_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    username_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:afterline.GetPublicUserInfoResponse.PublicUserInfo.username)
}

// optional string display_name = 2;
inline bool GetPublicUserInfoResponse_PublicUserInfo::_internal_has_display_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool GetPublicUserInfoResponse_PublicUserInfo::has_display_name() const {
  return _internal_has_display_name();
}
inline void GetPublicUserInfoResponse_PublicUserInfo::clear_display_name() {
  display_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& GetPublicUserInfoResponse_PublicUserInfo::display_name() const {
  // @@protoc_insertion_point(field_get:afterline.GetPublicUserInfoResponse.PublicUserInfo.display_name)
  return _internal_display_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetPublicUserInfoResponse_PublicUserInfo::set_display_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 display_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:afterline.GetPublicUserInfoResponse.PublicUserInfo.display_name)
}
inline std::string* GetPublicUserInfoResponse_PublicUserInfo::mutable_display_name() {
  std::string* _s = _internal_mutable_display_name();
  // @@protoc_insertion_point(field_mutable:afterline.GetPublicUserInfoResponse.PublicUserInfo.display_name)
  return _s;
}
inline const std::string& GetPublicUserInfoResponse_PublicUserInfo::_internal_display_name() const {
  return display_name_.Get();
}
inline void GetPublicUserInfoResponse_PublicUserInfo::_internal_set_display_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  display_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetPublicUserInfoResponse_PublicUserInfo::_internal_mutable_display_name() {
  _has_bits_[0] |= 0x00000001u;
  return display_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetPublicUserInfoResponse_PublicUserInfo::release_display_name() {
  // @@protoc_insertion_point(field_release:afterline.GetPublicUserInfoResponse.PublicUserInfo.display_name)
  if (!_internal_has_display_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = display_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (display_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    display_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void GetPublicUserInfoResponse_PublicUserInfo::set_allocated_display_name(std::string* display_name) {
  if (display_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  display_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), display_name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (display_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    display_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:afterline.GetPublicUserInfoResponse.PublicUserInfo.display_name)
}

// optional string user_desc = 3;
inline bool GetPublicUserInfoResponse_PublicUserInfo::_internal_has_user_desc() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool GetPublicUserInfoResponse_PublicUserInfo::has_user_desc() const {
  return _internal_has_user_desc();
}
inline void GetPublicUserInfoResponse_PublicUserInfo::clear_user_desc() {
  user_desc_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& GetPublicUserInfoResponse_PublicUserInfo::user_desc() const {
  // @@protoc_insertion_point(field_get:afterline.GetPublicUserInfoResponse.PublicUserInfo.user_desc)
  return _internal_user_desc();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetPublicUserInfoResponse_PublicUserInfo::set_user_desc(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 user_desc_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:afterline.GetPublicUserInfoResponse.PublicUserInfo.user_desc)
}
inline std::string* GetPublicUserInfoResponse_PublicUserInfo::mutable_user_desc() {
  std::string* _s = _internal_mutable_user_desc();
  // @@protoc_insertion_point(field_mutable:afterline.GetPublicUserInfoResponse.PublicUserInfo.user_desc)
  return _s;
}
inline const std::string& GetPublicUserInfoResponse_PublicUserInfo::_internal_user_desc() const {
  return user_desc_.Get();
}
inline void GetPublicUserInfoResponse_PublicUserInfo::_internal_set_user_desc(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  user_desc_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetPublicUserInfoResponse_PublicUserInfo::_internal_mutable_user_desc() {
  _has_bits_[0] |= 0x00000002u;
  return user_desc_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetPublicUserInfoResponse_PublicUserInfo::release_user_desc() {
  // @@protoc_insertion_point(field_release:afterline.GetPublicUserInfoResponse.PublicUserInfo.user_desc)
  if (!_internal_has_user_desc()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = user_desc_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (user_desc_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    user_desc_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void GetPublicUserInfoResponse_PublicUserInfo::set_allocated_user_desc(std::string* user_desc) {
  if (user_desc != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  user_desc_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), user_desc,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (user_desc_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    user_desc_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:afterline.GetPublicUserInfoResponse.PublicUserInfo.user_desc)
}

// optional string user_status_msg = 4;
inline bool GetPublicUserInfoResponse_PublicUserInfo::_internal_has_user_status_msg() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool GetPublicUserInfoResponse_PublicUserInfo::has_user_status_msg() const {
  return _internal_has_user_status_msg();
}
inline void GetPublicUserInfoResponse_PublicUserInfo::clear_user_status_msg() {
  user_status_msg_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& GetPublicUserInfoResponse_PublicUserInfo::user_status_msg() const {
  // @@protoc_insertion_point(field_get:afterline.GetPublicUserInfoResponse.PublicUserInfo.user_status_msg)
  return _internal_user_status_msg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetPublicUserInfoResponse_PublicUserInfo::set_user_status_msg(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 user_status_msg_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:afterline.GetPublicUserInfoResponse.PublicUserInfo.user_status_msg)
}
inline std::string* GetPublicUserInfoResponse_PublicUserInfo::mutable_user_status_msg() {
  std::string* _s = _internal_mutable_user_status_msg();
  // @@protoc_insertion_point(field_mutable:afterline.GetPublicUserInfoResponse.PublicUserInfo.user_status_msg)
  return _s;
}
inline const std::string& GetPublicUserInfoResponse_PublicUserInfo::_internal_user_status_msg() const {
  return user_status_msg_.Get();
}
inline void GetPublicUserInfoResponse_PublicUserInfo::_internal_set_user_status_msg(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  user_status_msg_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetPublicUserInfoResponse_PublicUserInfo::_internal_mutable_user_status_msg() {
  _has_bits_[0] |= 0x00000004u;
  return user_status_msg_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetPublicUserInfoResponse_PublicUserInfo::release_user_status_msg() {
  // @@protoc_insertion_point(field_release:afterline.GetPublicUserInfoResponse.PublicUserInfo.user_status_msg)
  if (!_internal_has_user_status_msg()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  auto* p = user_status_msg_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (user_status_msg_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    user_status_msg_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void GetPublicUserInfoResponse_PublicUserInfo::set_allocated_user_status_msg(std::string* user_status_msg) {
  if (user_status_msg != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  user_status_msg_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), user_status_msg,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (user_status_msg_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    user_status_msg_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:afterline.GetPublicUserInfoResponse.PublicUserInfo.user_status_msg)
}

// .afterline.GetPublicUserInfoResponse.PublicUserInfo.Status status = 5;
inline void GetPublicUserInfoResponse_PublicUserInfo::clear_status() {
  status_ = 0;
}
inline ::afterline::GetPublicUserInfoResponse_PublicUserInfo_Status GetPublicUserInfoResponse_PublicUserInfo::_internal_status() const {
  return static_cast< ::afterline::GetPublicUserInfoResponse_PublicUserInfo_Status >(status_);
}
inline ::afterline::GetPublicUserInfoResponse_PublicUserInfo_Status GetPublicUserInfoResponse_PublicUserInfo::status() const {
  // @@protoc_insertion_point(field_get:afterline.GetPublicUserInfoResponse.PublicUserInfo.status)
  return _internal_status();
}
inline void GetPublicUserInfoResponse_PublicUserInfo::_internal_set_status(::afterline::GetPublicUserInfoResponse_PublicUserInfo_Status value) {
  
  status_ = value;
}
inline void GetPublicUserInfoResponse_PublicUserInfo::set_status(::afterline::GetPublicUserInfoResponse_PublicUserInfo_Status value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:afterline.GetPublicUserInfoResponse.PublicUserInfo.status)
}

// optional .afterline.IconSetInfo icon_set = 6;
inline bool GetPublicUserInfoResponse_PublicUserInfo::_internal_has_icon_set() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || icon_set_ != nullptr);
  return value;
}
inline bool GetPublicUserInfoResponse_PublicUserInfo::has_icon_set() const {
  return _internal_has_icon_set();
}
inline const ::afterline::IconSetInfo& GetPublicUserInfoResponse_PublicUserInfo::_internal_icon_set() const {
  const ::afterline::IconSetInfo* p = icon_set_;
  return p != nullptr ? *p : reinterpret_cast<const ::afterline::IconSetInfo&>(
      ::afterline::_IconSetInfo_default_instance_);
}
inline const ::afterline::IconSetInfo& GetPublicUserInfoResponse_PublicUserInfo::icon_set() const {
  // @@protoc_insertion_point(field_get:afterline.GetPublicUserInfoResponse.PublicUserInfo.icon_set)
  return _internal_icon_set();
}
inline void GetPublicUserInfoResponse_PublicUserInfo::unsafe_arena_set_allocated_icon_set(
    ::afterline::IconSetInfo* icon_set) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(icon_set_);
  }
  icon_set_ = icon_set;
  if (icon_set) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:afterline.GetPublicUserInfoResponse.PublicUserInfo.icon_set)
}
inline ::afterline::IconSetInfo* GetPublicUserInfoResponse_PublicUserInfo::release_icon_set() {
  _has_bits_[0] &= ~0x00000008u;
  ::afterline::IconSetInfo* temp = icon_set_;
  icon_set_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::afterline::IconSetInfo* GetPublicUserInfoResponse_PublicUserInfo::unsafe_arena_release_icon_set() {
  // @@protoc_insertion_point(field_release:afterline.GetPublicUserInfoResponse.PublicUserInfo.icon_set)
  _has_bits_[0] &= ~0x00000008u;
  ::afterline::IconSetInfo* temp = icon_set_;
  icon_set_ = nullptr;
  return temp;
}
inline ::afterline::IconSetInfo* GetPublicUserInfoResponse_PublicUserInfo::_internal_mutable_icon_set() {
  _has_bits_[0] |= 0x00000008u;
  if (icon_set_ == nullptr) {
    auto* p = CreateMaybeMessage<::afterline::IconSetInfo>(GetArenaForAllocation());
    icon_set_ = p;
  }
  return icon_set_;
}
inline ::afterline::IconSetInfo* GetPublicUserInfoResponse_PublicUserInfo::mutable_icon_set() {
  ::afterline::IconSetInfo* _msg = _internal_mutable_icon_set();
  // @@protoc_insertion_point(field_mutable:afterline.GetPublicUserInfoResponse.PublicUserInfo.icon_set)
  return _msg;
}
inline void GetPublicUserInfoResponse_PublicUserInfo::set_allocated_icon_set(::afterline::IconSetInfo* icon_set) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(icon_set_);
  }
  if (icon_set) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(icon_set));
    if (message_arena != submessage_arena) {
      icon_set = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, icon_set, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  icon_set_ = icon_set;
  // @@protoc_insertion_point(field_set_allocated:afterline.GetPublicUserInfoResponse.PublicUserInfo.icon_set)
}

// repeated fixed64 public_games_joined = 7;
inline int GetPublicUserInfoResponse_PublicUserInfo::_internal_public_games_joined_size() const {
  return public_games_joined_.size();
}
inline int GetPublicUserInfoResponse_PublicUserInfo::public_games_joined_size() const {
  return _internal_public_games_joined_size();
}
inline void GetPublicUserInfoResponse_PublicUserInfo::clear_public_games_joined() {
  public_games_joined_.Clear();
}
inline uint64_t GetPublicUserInfoResponse_PublicUserInfo::_internal_public_games_joined(int index) const {
  return public_games_joined_.Get(index);
}
inline uint64_t GetPublicUserInfoResponse_PublicUserInfo::public_games_joined(int index) const {
  // @@protoc_insertion_point(field_get:afterline.GetPublicUserInfoResponse.PublicUserInfo.public_games_joined)
  return _internal_public_games_joined(index);
}
inline void GetPublicUserInfoResponse_PublicUserInfo::set_public_games_joined(int index, uint64_t value) {
  public_games_joined_.Set(index, value);
  // @@protoc_insertion_point(field_set:afterline.GetPublicUserInfoResponse.PublicUserInfo.public_games_joined)
}
inline void GetPublicUserInfoResponse_PublicUserInfo::_internal_add_public_games_joined(uint64_t value) {
  public_games_joined_.Add(value);
}
inline void GetPublicUserInfoResponse_PublicUserInfo::add_public_games_joined(uint64_t value) {
  _internal_add_public_games_joined(value);
  // @@protoc_insertion_point(field_add:afterline.GetPublicUserInfoResponse.PublicUserInfo.public_games_joined)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
GetPublicUserInfoResponse_PublicUserInfo::_internal_public_games_joined() const {
  return public_games_joined_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
GetPublicUserInfoResponse_PublicUserInfo::public_games_joined() const {
  // @@protoc_insertion_point(field_list:afterline.GetPublicUserInfoResponse.PublicUserInfo.public_games_joined)
  return _internal_public_games_joined();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
GetPublicUserInfoResponse_PublicUserInfo::_internal_mutable_public_games_joined() {
  return &public_games_joined_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
GetPublicUserInfoResponse_PublicUserInfo::mutable_public_games_joined() {
  // @@protoc_insertion_point(field_mutable_list:afterline.GetPublicUserInfoResponse.PublicUserInfo.public_games_joined)
  return _internal_mutable_public_games_joined();
}

// repeated fixed64 friends = 8;
inline int GetPublicUserInfoResponse_PublicUserInfo::_internal_friends_size() const {
  return friends_.size();
}
inline int GetPublicUserInfoResponse_PublicUserInfo::friends_size() const {
  return _internal_friends_size();
}
inline void GetPublicUserInfoResponse_PublicUserInfo::clear_friends() {
  friends_.Clear();
}
inline uint64_t GetPublicUserInfoResponse_PublicUserInfo::_internal_friends(int index) const {
  return friends_.Get(index);
}
inline uint64_t GetPublicUserInfoResponse_PublicUserInfo::friends(int index) const {
  // @@protoc_insertion_point(field_get:afterline.GetPublicUserInfoResponse.PublicUserInfo.friends)
  return _internal_friends(index);
}
inline void GetPublicUserInfoResponse_PublicUserInfo::set_friends(int index, uint64_t value) {
  friends_.Set(index, value);
  // @@protoc_insertion_point(field_set:afterline.GetPublicUserInfoResponse.PublicUserInfo.friends)
}
inline void GetPublicUserInfoResponse_PublicUserInfo::_internal_add_friends(uint64_t value) {
  friends_.Add(value);
}
inline void GetPublicUserInfoResponse_PublicUserInfo::add_friends(uint64_t value) {
  _internal_add_friends(value);
  // @@protoc_insertion_point(field_add:afterline.GetPublicUserInfoResponse.PublicUserInfo.friends)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
GetPublicUserInfoResponse_PublicUserInfo::_internal_friends() const {
  return friends_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
GetPublicUserInfoResponse_PublicUserInfo::friends() const {
  // @@protoc_insertion_point(field_list:afterline.GetPublicUserInfoResponse.PublicUserInfo.friends)
  return _internal_friends();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
GetPublicUserInfoResponse_PublicUserInfo::_internal_mutable_friends() {
  return &friends_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
GetPublicUserInfoResponse_PublicUserInfo::mutable_friends() {
  // @@protoc_insertion_point(field_mutable_list:afterline.GetPublicUserInfoResponse.PublicUserInfo.friends)
  return _internal_mutable_friends();
}

// -------------------------------------------------------------------

// GetPublicUserInfoResponse

// fixed64 user_id = 1;
inline void GetPublicUserInfoResponse::clear_user_id() {
  user_id_ = uint64_t{0u};
}
inline uint64_t GetPublicUserInfoResponse::_internal_user_id() const {
  return user_id_;
}
inline uint64_t GetPublicUserInfoResponse::user_id() const {
  // @@protoc_insertion_point(field_get:afterline.GetPublicUserInfoResponse.user_id)
  return _internal_user_id();
}
inline void GetPublicUserInfoResponse::_internal_set_user_id(uint64_t value) {
  
  user_id_ = value;
}
inline void GetPublicUserInfoResponse::set_user_id(uint64_t value) {
  _internal_set_user_id(value);
  // @@protoc_insertion_point(field_set:afterline.GetPublicUserInfoResponse.user_id)
}

// optional .afterline.GetPublicUserInfoResponse.PublicUserInfo user_info = 2;
inline bool GetPublicUserInfoResponse::_internal_has_user_info() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || user_info_ != nullptr);
  return value;
}
inline bool GetPublicUserInfoResponse::has_user_info() const {
  return _internal_has_user_info();
}
inline void GetPublicUserInfoResponse::clear_user_info() {
  if (user_info_ != nullptr) user_info_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::afterline::GetPublicUserInfoResponse_PublicUserInfo& GetPublicUserInfoResponse::_internal_user_info() const {
  const ::afterline::GetPublicUserInfoResponse_PublicUserInfo* p = user_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::afterline::GetPublicUserInfoResponse_PublicUserInfo&>(
      ::afterline::_GetPublicUserInfoResponse_PublicUserInfo_default_instance_);
}
inline const ::afterline::GetPublicUserInfoResponse_PublicUserInfo& GetPublicUserInfoResponse::user_info() const {
  // @@protoc_insertion_point(field_get:afterline.GetPublicUserInfoResponse.user_info)
  return _internal_user_info();
}
inline void GetPublicUserInfoResponse::unsafe_arena_set_allocated_user_info(
    ::afterline::GetPublicUserInfoResponse_PublicUserInfo* user_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(user_info_);
  }
  user_info_ = user_info;
  if (user_info) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:afterline.GetPublicUserInfoResponse.user_info)
}
inline ::afterline::GetPublicUserInfoResponse_PublicUserInfo* GetPublicUserInfoResponse::release_user_info() {
  _has_bits_[0] &= ~0x00000001u;
  ::afterline::GetPublicUserInfoResponse_PublicUserInfo* temp = user_info_;
  user_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::afterline::GetPublicUserInfoResponse_PublicUserInfo* GetPublicUserInfoResponse::unsafe_arena_release_user_info() {
  // @@protoc_insertion_point(field_release:afterline.GetPublicUserInfoResponse.user_info)
  _has_bits_[0] &= ~0x00000001u;
  ::afterline::GetPublicUserInfoResponse_PublicUserInfo* temp = user_info_;
  user_info_ = nullptr;
  return temp;
}
inline ::afterline::GetPublicUserInfoResponse_PublicUserInfo* GetPublicUserInfoResponse::_internal_mutable_user_info() {
  _has_bits_[0] |= 0x00000001u;
  if (user_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::afterline::GetPublicUserInfoResponse_PublicUserInfo>(GetArenaForAllocation());
    user_info_ = p;
  }
  return user_info_;
}
inline ::afterline::GetPublicUserInfoResponse_PublicUserInfo* GetPublicUserInfoResponse::mutable_user_info() {
  ::afterline::GetPublicUserInfoResponse_PublicUserInfo* _msg = _internal_mutable_user_info();
  // @@protoc_insertion_point(field_mutable:afterline.GetPublicUserInfoResponse.user_info)
  return _msg;
}
inline void GetPublicUserInfoResponse::set_allocated_user_info(::afterline::GetPublicUserInfoResponse_PublicUserInfo* user_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete user_info_;
  }
  if (user_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::afterline::GetPublicUserInfoResponse_PublicUserInfo>::GetOwningArena(user_info);
    if (message_arena != submessage_arena) {
      user_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, user_info, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  user_info_ = user_info;
  // @@protoc_insertion_point(field_set_allocated:afterline.GetPublicUserInfoResponse.user_info)
}

// -------------------------------------------------------------------

// GetUserIDRequest

// fixed64 session_id = 1;
inline void GetUserIDRequest::clear_session_id() {
  session_id_ = uint64_t{0u};
}
inline uint64_t GetUserIDRequest::_internal_session_id() const {
  return session_id_;
}
inline uint64_t GetUserIDRequest::session_id() const {
  // @@protoc_insertion_point(field_get:afterline.GetUserIDRequest.session_id)
  return _internal_session_id();
}
inline void GetUserIDRequest::_internal_set_session_id(uint64_t value) {
  
  session_id_ = value;
}
inline void GetUserIDRequest::set_session_id(uint64_t value) {
  _internal_set_session_id(value);
  // @@protoc_insertion_point(field_set:afterline.GetUserIDRequest.session_id)
}

// -------------------------------------------------------------------

// GetUserIDResponse

// fixed64 user_id = 1;
inline void GetUserIDResponse::clear_user_id() {
  user_id_ = uint64_t{0u};
}
inline uint64_t GetUserIDResponse::_internal_user_id() const {
  return user_id_;
}
inline uint64_t GetUserIDResponse::user_id() const {
  // @@protoc_insertion_point(field_get:afterline.GetUserIDResponse.user_id)
  return _internal_user_id();
}
inline void GetUserIDResponse::_internal_set_user_id(uint64_t value) {
  
  user_id_ = value;
}
inline void GetUserIDResponse::set_user_id(uint64_t value) {
  _internal_set_user_id(value);
  // @@protoc_insertion_point(field_set:afterline.GetUserIDResponse.user_id)
}

// -------------------------------------------------------------------

// FindUserRequest

// fixed64 session_id = 1;
inline void FindUserRequest::clear_session_id() {
  session_id_ = uint64_t{0u};
}
inline uint64_t FindUserRequest::_internal_session_id() const {
  return session_id_;
}
inline uint64_t FindUserRequest::session_id() const {
  // @@protoc_insertion_point(field_get:afterline.FindUserRequest.session_id)
  return _internal_session_id();
}
inline void FindUserRequest::_internal_set_session_id(uint64_t value) {
  
  session_id_ = value;
}
inline void FindUserRequest::set_session_id(uint64_t value) {
  _internal_set_session_id(value);
  // @@protoc_insertion_point(field_set:afterline.FindUserRequest.session_id)
}

// string search_term = 2;
inline void FindUserRequest::clear_search_term() {
  search_term_.ClearToEmpty();
}
inline const std::string& FindUserRequest::search_term() const {
  // @@protoc_insertion_point(field_get:afterline.FindUserRequest.search_term)
  return _internal_search_term();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FindUserRequest::set_search_term(ArgT0&& arg0, ArgT... args) {
 
 search_term_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:afterline.FindUserRequest.search_term)
}
inline std::string* FindUserRequest::mutable_search_term() {
  std::string* _s = _internal_mutable_search_term();
  // @@protoc_insertion_point(field_mutable:afterline.FindUserRequest.search_term)
  return _s;
}
inline const std::string& FindUserRequest::_internal_search_term() const {
  return search_term_.Get();
}
inline void FindUserRequest::_internal_set_search_term(const std::string& value) {
  
  search_term_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* FindUserRequest::_internal_mutable_search_term() {
  
  return search_term_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* FindUserRequest::release_search_term() {
  // @@protoc_insertion_point(field_release:afterline.FindUserRequest.search_term)
  return search_term_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void FindUserRequest::set_allocated_search_term(std::string* search_term) {
  if (search_term != nullptr) {
    
  } else {
    
  }
  search_term_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), search_term,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (search_term_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    search_term_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:afterline.FindUserRequest.search_term)
}

// -------------------------------------------------------------------

// FindUserResponse

// repeated fixed64 users = 1;
inline int FindUserResponse::_internal_users_size() const {
  return users_.size();
}
inline int FindUserResponse::users_size() const {
  return _internal_users_size();
}
inline void FindUserResponse::clear_users() {
  users_.Clear();
}
inline uint64_t FindUserResponse::_internal_users(int index) const {
  return users_.Get(index);
}
inline uint64_t FindUserResponse::users(int index) const {
  // @@protoc_insertion_point(field_get:afterline.FindUserResponse.users)
  return _internal_users(index);
}
inline void FindUserResponse::set_users(int index, uint64_t value) {
  users_.Set(index, value);
  // @@protoc_insertion_point(field_set:afterline.FindUserResponse.users)
}
inline void FindUserResponse::_internal_add_users(uint64_t value) {
  users_.Add(value);
}
inline void FindUserResponse::add_users(uint64_t value) {
  _internal_add_users(value);
  // @@protoc_insertion_point(field_add:afterline.FindUserResponse.users)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
FindUserResponse::_internal_users() const {
  return users_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
FindUserResponse::users() const {
  // @@protoc_insertion_point(field_list:afterline.FindUserResponse.users)
  return _internal_users();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
FindUserResponse::_internal_mutable_users() {
  return &users_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
FindUserResponse::mutable_users() {
  // @@protoc_insertion_point(field_mutable_list:afterline.FindUserResponse.users)
  return _internal_mutable_users();
}

// -------------------------------------------------------------------

// BlockUserRequest

// fixed64 session_id = 1;
inline void BlockUserRequest::clear_session_id() {
  session_id_ = uint64_t{0u};
}
inline uint64_t BlockUserRequest::_internal_session_id() const {
  return session_id_;
}
inline uint64_t BlockUserRequest::session_id() const {
  // @@protoc_insertion_point(field_get:afterline.BlockUserRequest.session_id)
  return _internal_session_id();
}
inline void BlockUserRequest::_internal_set_session_id(uint64_t value) {
  
  session_id_ = value;
}
inline void BlockUserRequest::set_session_id(uint64_t value) {
  _internal_set_session_id(value);
  // @@protoc_insertion_point(field_set:afterline.BlockUserRequest.session_id)
}

// fixed64 user_id = 2;
inline void BlockUserRequest::clear_user_id() {
  user_id_ = uint64_t{0u};
}
inline uint64_t BlockUserRequest::_internal_user_id() const {
  return user_id_;
}
inline uint64_t BlockUserRequest::user_id() const {
  // @@protoc_insertion_point(field_get:afterline.BlockUserRequest.user_id)
  return _internal_user_id();
}
inline void BlockUserRequest::_internal_set_user_id(uint64_t value) {
  
  user_id_ = value;
}
inline void BlockUserRequest::set_user_id(uint64_t value) {
  _internal_set_user_id(value);
  // @@protoc_insertion_point(field_set:afterline.BlockUserRequest.user_id)
}

// bool block = 3;
inline void BlockUserRequest::clear_block() {
  block_ = false;
}
inline bool BlockUserRequest::_internal_block() const {
  return block_;
}
inline bool BlockUserRequest::block() const {
  // @@protoc_insertion_point(field_get:afterline.BlockUserRequest.block)
  return _internal_block();
}
inline void BlockUserRequest::_internal_set_block(bool value) {
  
  block_ = value;
}
inline void BlockUserRequest::set_block(bool value) {
  _internal_set_block(value);
  // @@protoc_insertion_point(field_set:afterline.BlockUserRequest.block)
}

// -------------------------------------------------------------------

// BlockUserResponse

// fixed64 session_id = 1;
inline void BlockUserResponse::clear_session_id() {
  session_id_ = uint64_t{0u};
}
inline uint64_t BlockUserResponse::_internal_session_id() const {
  return session_id_;
}
inline uint64_t BlockUserResponse::session_id() const {
  // @@protoc_insertion_point(field_get:afterline.BlockUserResponse.session_id)
  return _internal_session_id();
}
inline void BlockUserResponse::_internal_set_session_id(uint64_t value) {
  
  session_id_ = value;
}
inline void BlockUserResponse::set_session_id(uint64_t value) {
  _internal_set_session_id(value);
  // @@protoc_insertion_point(field_set:afterline.BlockUserResponse.session_id)
}

// fixed64 user_id = 2;
inline void BlockUserResponse::clear_user_id() {
  user_id_ = uint64_t{0u};
}
inline uint64_t BlockUserResponse::_internal_user_id() const {
  return user_id_;
}
inline uint64_t BlockUserResponse::user_id() const {
  // @@protoc_insertion_point(field_get:afterline.BlockUserResponse.user_id)
  return _internal_user_id();
}
inline void BlockUserResponse::_internal_set_user_id(uint64_t value) {
  
  user_id_ = value;
}
inline void BlockUserResponse::set_user_id(uint64_t value) {
  _internal_set_user_id(value);
  // @@protoc_insertion_point(field_set:afterline.BlockUserResponse.user_id)
}

// bool successful = 3;
inline void BlockUserResponse::clear_successful() {
  successful_ = false;
}
inline bool BlockUserResponse::_internal_successful() const {
  return successful_;
}
inline bool BlockUserResponse::successful() const {
  // @@protoc_insertion_point(field_get:afterline.BlockUserResponse.successful)
  return _internal_successful();
}
inline void BlockUserResponse::_internal_set_successful(bool value) {
  
  successful_ = value;
}
inline void BlockUserResponse::set_successful(bool value) {
  _internal_set_successful(value);
  // @@protoc_insertion_point(field_set:afterline.BlockUserResponse.successful)
}

// -------------------------------------------------------------------

// FriendUserRequest

// fixed64 session_id = 1;
inline void FriendUserRequest::clear_session_id() {
  session_id_ = uint64_t{0u};
}
inline uint64_t FriendUserRequest::_internal_session_id() const {
  return session_id_;
}
inline uint64_t FriendUserRequest::session_id() const {
  // @@protoc_insertion_point(field_get:afterline.FriendUserRequest.session_id)
  return _internal_session_id();
}
inline void FriendUserRequest::_internal_set_session_id(uint64_t value) {
  
  session_id_ = value;
}
inline void FriendUserRequest::set_session_id(uint64_t value) {
  _internal_set_session_id(value);
  // @@protoc_insertion_point(field_set:afterline.FriendUserRequest.session_id)
}

// fixed64 user_id = 2;
inline void FriendUserRequest::clear_user_id() {
  user_id_ = uint64_t{0u};
}
inline uint64_t FriendUserRequest::_internal_user_id() const {
  return user_id_;
}
inline uint64_t FriendUserRequest::user_id() const {
  // @@protoc_insertion_point(field_get:afterline.FriendUserRequest.user_id)
  return _internal_user_id();
}
inline void FriendUserRequest::_internal_set_user_id(uint64_t value) {
  
  user_id_ = value;
}
inline void FriendUserRequest::set_user_id(uint64_t value) {
  _internal_set_user_id(value);
  // @@protoc_insertion_point(field_set:afterline.FriendUserRequest.user_id)
}

// -------------------------------------------------------------------

// FriendUserResponse

// fixed64 session_id = 1;
inline void FriendUserResponse::clear_session_id() {
  session_id_ = uint64_t{0u};
}
inline uint64_t FriendUserResponse::_internal_session_id() const {
  return session_id_;
}
inline uint64_t FriendUserResponse::session_id() const {
  // @@protoc_insertion_point(field_get:afterline.FriendUserResponse.session_id)
  return _internal_session_id();
}
inline void FriendUserResponse::_internal_set_session_id(uint64_t value) {
  
  session_id_ = value;
}
inline void FriendUserResponse::set_session_id(uint64_t value) {
  _internal_set_session_id(value);
  // @@protoc_insertion_point(field_set:afterline.FriendUserResponse.session_id)
}

// fixed64 user_id = 2;
inline void FriendUserResponse::clear_user_id() {
  user_id_ = uint64_t{0u};
}
inline uint64_t FriendUserResponse::_internal_user_id() const {
  return user_id_;
}
inline uint64_t FriendUserResponse::user_id() const {
  // @@protoc_insertion_point(field_get:afterline.FriendUserResponse.user_id)
  return _internal_user_id();
}
inline void FriendUserResponse::_internal_set_user_id(uint64_t value) {
  
  user_id_ = value;
}
inline void FriendUserResponse::set_user_id(uint64_t value) {
  _internal_set_user_id(value);
  // @@protoc_insertion_point(field_set:afterline.FriendUserResponse.user_id)
}

// -------------------------------------------------------------------

// UnFriendUserRequest

// fixed64 session_id = 1;
inline void UnFriendUserRequest::clear_session_id() {
  session_id_ = uint64_t{0u};
}
inline uint64_t UnFriendUserRequest::_internal_session_id() const {
  return session_id_;
}
inline uint64_t UnFriendUserRequest::session_id() const {
  // @@protoc_insertion_point(field_get:afterline.UnFriendUserRequest.session_id)
  return _internal_session_id();
}
inline void UnFriendUserRequest::_internal_set_session_id(uint64_t value) {
  
  session_id_ = value;
}
inline void UnFriendUserRequest::set_session_id(uint64_t value) {
  _internal_set_session_id(value);
  // @@protoc_insertion_point(field_set:afterline.UnFriendUserRequest.session_id)
}

// fixed64 user_id = 2;
inline void UnFriendUserRequest::clear_user_id() {
  user_id_ = uint64_t{0u};
}
inline uint64_t UnFriendUserRequest::_internal_user_id() const {
  return user_id_;
}
inline uint64_t UnFriendUserRequest::user_id() const {
  // @@protoc_insertion_point(field_get:afterline.UnFriendUserRequest.user_id)
  return _internal_user_id();
}
inline void UnFriendUserRequest::_internal_set_user_id(uint64_t value) {
  
  user_id_ = value;
}
inline void UnFriendUserRequest::set_user_id(uint64_t value) {
  _internal_set_user_id(value);
  // @@protoc_insertion_point(field_set:afterline.UnFriendUserRequest.user_id)
}

// -------------------------------------------------------------------

// UnFriendUserResponse

// fixed64 user_id = 1;
inline void UnFriendUserResponse::clear_user_id() {
  user_id_ = uint64_t{0u};
}
inline uint64_t UnFriendUserResponse::_internal_user_id() const {
  return user_id_;
}
inline uint64_t UnFriendUserResponse::user_id() const {
  // @@protoc_insertion_point(field_get:afterline.UnFriendUserResponse.user_id)
  return _internal_user_id();
}
inline void UnFriendUserResponse::_internal_set_user_id(uint64_t value) {
  
  user_id_ = value;
}
inline void UnFriendUserResponse::set_user_id(uint64_t value) {
  _internal_set_user_id(value);
  // @@protoc_insertion_point(field_set:afterline.UnFriendUserResponse.user_id)
}

// bool successful = 2;
inline void UnFriendUserResponse::clear_successful() {
  successful_ = false;
}
inline bool UnFriendUserResponse::_internal_successful() const {
  return successful_;
}
inline bool UnFriendUserResponse::successful() const {
  // @@protoc_insertion_point(field_get:afterline.UnFriendUserResponse.successful)
  return _internal_successful();
}
inline void UnFriendUserResponse::_internal_set_successful(bool value) {
  
  successful_ = value;
}
inline void UnFriendUserResponse::set_successful(bool value) {
  _internal_set_successful(value);
  // @@protoc_insertion_point(field_set:afterline.UnFriendUserResponse.successful)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace afterline

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::afterline::GetPublicUserInfoResponse_PublicUserInfo_Status> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::afterline::GetPublicUserInfoResponse_PublicUserInfo_Status>() {
  return ::afterline::GetPublicUserInfoResponse_PublicUserInfo_Status_descriptor();
}
template <> struct is_proto_enum< ::afterline::FriendUserResponse_Status> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::afterline::FriendUserResponse_Status>() {
  return ::afterline::FriendUserResponse_Status_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_afterline_2fsystem_2eproto
